<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>node.js | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="node.js阶段总结 什么是前端和后端后端的主要工作 后端为前端程序员暴露API接口； 后端也要操作数据库； 优化后端业务的性能；前端的主要工作 绘制网页的页面（HTML） 写CSS样式美化页面、写JS做网页交互（更多的是网页的特效） 借助于 XHR（$.ajax   $.get   $.post）请求后端的接口；实现前后端分离开发 使用前端的（框架）去完成界面的开发 总结：前端的主要工作：用户">
<meta property="og:type" content="article">
<meta property="og:title" content="node.js">
<meta property="og:url" content="http://yoursite.com/2018/07/11/node-js/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="node.js阶段总结 什么是前端和后端后端的主要工作 后端为前端程序员暴露API接口； 后端也要操作数据库； 优化后端业务的性能；前端的主要工作 绘制网页的页面（HTML） 写CSS样式美化页面、写JS做网页交互（更多的是网页的特效） 借助于 XHR（$.ajax   $.get   $.post）请求后端的接口；实现前后端分离开发 使用前端的（框架）去完成界面的开发 总结：前端的主要工作：用户">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-07-11T12:54:32.835Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="node.js">
<meta name="twitter:description" content="node.js阶段总结 什么是前端和后端后端的主要工作 后端为前端程序员暴露API接口； 后端也要操作数据库； 优化后端业务的性能；前端的主要工作 绘制网页的页面（HTML） 写CSS样式美化页面、写JS做网页交互（更多的是网页的特效） 借助于 XHR（$.ajax   $.get   $.post）请求后端的接口；实现前后端分离开发 使用前端的（框架）去完成界面的开发 总结：前端的主要工作：用户">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Cecilia</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-node-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/11/node-js/" class="article-date">
  <time datetime="2018-07-11T12:37:37.000Z" itemprop="datePublished">2018-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      node.js
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="node-js阶段总结"><a href="#node-js阶段总结" class="headerlink" title="node.js阶段总结"></a>node.js阶段总结</h1><hr>
<h2 id="什么是前端和后端"><a href="#什么是前端和后端" class="headerlink" title="什么是前端和后端"></a>什么是前端和后端</h2><h3 id="后端的主要工作"><a href="#后端的主要工作" class="headerlink" title="后端的主要工作"></a>后端的主要工作</h3><ol>
<li>后端为前端程序员暴露API接口；</li>
<li>后端也要操作数据库；</li>
<li>优化后端业务的性能；<h3 id="前端的主要工作"><a href="#前端的主要工作" class="headerlink" title="前端的主要工作"></a>前端的主要工作</h3></li>
<li>绘制网页的页面（HTML）</li>
<li>写CSS样式美化页面、写JS做网页交互（更多的是网页的特效）</li>
<li>借助于 XHR（$.ajax   $.get   $.post）请求后端的接口；实现前后端分离开发</li>
<li>使用前端的（框架）去完成界面的开发</li>
<li>总结：前端的主要工作：用户能看到的东西，基本上都是前端做出来；<h3 id="前后端协作流程"><a href="#前后端协作流程" class="headerlink" title="前后端协作流程"></a>前后端协作流程</h3></li>
</ol>
<ul>
<li>将来进入工作，大家会接触到【前后端分离开发】；</li>
<li>协作开发的流程：后端为我们暴露数据接口，前端单纯的调用后端接口；</li>
<li>在当前Node阶段中，我们学习的是 后端开发；</li>
<li>在Node阶段，我们主要教大家如何写后端的接口；</li>
</ul>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="LTS-和-Current-版本区别"><a href="#LTS-和-Current-版本区别" class="headerlink" title="LTS 和 Current 版本区别"></a>LTS 和 Current 版本区别</h3><ol>
<li>LTS 是长期稳定版的意思（这个安装包用起来比较稳定）【推荐在企业中使用】</li>
<li>Current 是最新特征版，这个安装包中有最新的Node特性，但是，可能有一些潜藏的Bug未解决；【推荐学习或尝鲜去使用】<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h4 id="查看-Node-版本号"><a href="#查看-Node-版本号" class="headerlink" title="查看 Node 版本号"></a>查看 Node 版本号</h4>打开终端，在命令行输入命令<code>node -v</code>即可<br>如何进入终端呢？</li>
<li>使用快捷键<code>windows徽标 + R</code>打开运行面板，输入 <code>cmd</code> 后直接回车；</li>
<li>在任意目录的空白位置，先按住<code>shift</code>键不松开，然后，在空白位置，鼠标右键单击，会出来一个右键菜单，选择<code>在此处打开 powershell/cmd 窗口</code>【将来第二种方式用的会多一些】<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h4 id="什么是环境变量"><a href="#什么是环境变量" class="headerlink" title="什么是环境变量"></a>什么是环境变量</h4>Path环境变量的作用：能够让我们通过命令行的形式，快速启动一些应用程序；<h4 id="系统环境变量和用户环境变量的区别"><a href="#系统环境变量和用户环境变量的区别" class="headerlink" title="系统环境变量和用户环境变量的区别"></a>系统环境变量和用户环境变量的区别</h4></li>
<li>用户环境变量，是每个用户私有的，用户之间不会共享；</li>
<li>全局环境变量，是共享的，只要你能登录这台计算机，就能访问到全局的环境变量；【今后在配置环境变量的时候，推荐直接配置到系统环境变量】<h4 id="通过命令行快速启动应用程序时，路径的查找规则"><a href="#通过命令行快速启动应用程序时，路径的查找规则" class="headerlink" title="通过命令行快速启动应用程序时，路径的查找规则"></a>通过命令行快速启动应用程序时，路径的查找规则</h4></li>
<li>先在当前 cmd 终端的目录中查找，如果有则直接运行；</li>
<li>如果当前目录中没有，则去全局的path环境变量中查找；</li>
</ol>
<h2 id="浏览器中的-JavaScript"><a href="#浏览器中的-JavaScript" class="headerlink" title="浏览器中的 JavaScript"></a>浏览器中的 JavaScript</h2><h3 id="Javascript的诞生"><a href="#Javascript的诞生" class="headerlink" title="Javascript的诞生"></a>Javascript的诞生</h3><ol>
<li>JS 诞生 和 网景公司 有关；form</li>
<li>JS 诞生的需求，就是为了做客户端表单验证的；</li>
<li>JS作者刚把JS创建出来之后，它叫 LiveScript  -&gt;   Javascript<h3 id="浏览器一战"><a href="#浏览器一战" class="headerlink" title="浏览器一战"></a>浏览器一战</h3>主角是 IE 和 网景浏览器；</li>
<li>一战的果实：ECMAScript 规范的确立！</li>
<li>短暂的和平期：在和平期阶段，JS都在做什么事情呢（进行表单的验证、做简单的网页动效、狗皮膏药），一战之后，JS能力有限，当时被称作是“脚本语言”<h3 id="浏览器二战"><a href="#浏览器二战" class="headerlink" title="浏览器二战"></a>浏览器二战</h3></li>
</ol>
<ul>
<li>在 2008 年，二战开始了；</li>
<li>谷歌chrome、IE、火狐（浴火重生）</li>
<li>在 2008 年，谷歌 利用 XHR 这个对象，实现了网页的局部刷新；</li>
<li>2010 - 2013年左右，公司中，不管是Java，还是.NET, 还是 PHP（会不会Ajax）</li>
</ul>
<ol>
<li>二战的果实：XHR 对象的诞生； chrome 浏览器的 JS V8 解析引擎；<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3></li>
</ol>
<ul>
<li>在 一战 和 二战期间，JS 只能运行在 浏览器中；<br>浏览器中的JS组成部分：ECMAScript核心 + DOM + BOM<br>浏览器属于前端环境，所以，之前的JS只运行在前端浏览器中；也就是，无法使用Javascript实现后端编程；</li>
</ul>
<h2 id="Node中的Javascript"><a href="#Node中的Javascript" class="headerlink" title="Node中的Javascript"></a>Node中的Javascript</h2><ul>
<li>Node.js 的诞生，解放了Javascript，从此之后，Javascript 就可以在 服务器端运行了；<h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3></li>
<li>Node中的Javascript也有一个ECMAScript核心<h3 id="没有-BOM-和-DOM"><a href="#没有-BOM-和-DOM" class="headerlink" title="没有 BOM 和 DOM"></a>没有 BOM 和 DOM</h3></li>
<li>Node中并没有浏览器的概念，所以，BOM和 DOM ，Node中不需要，因此，就把它们给剔除了；<h3 id="全局成员-网页和Node中都可以用"><a href="#全局成员-网页和Node中都可以用" class="headerlink" title="全局成员(网页和Node中都可以用)"></a>全局成员(网页和Node中都可以用)</h3></li>
</ul>
<ol>
<li>console</li>
<li>setInterval</li>
<li>setTimeout</li>
<li>…其它全局成员<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3></li>
<li>Node中自己扩展出来的一套API规范<h3 id="Node中的JS组成部分"><a href="#Node中的JS组成部分" class="headerlink" title="Node中的JS组成部分"></a>Node中的JS组成部分</h3></li>
</ol>
<ul>
<li>ECMAScript核心 + 全局成员 + 模块系统成员（这是Node平台所独有的）</li>
</ul>
<ol>
<li>全局成员（console.log,   setTimeout  setInterval）</li>
<li>模块系统成员（就是Node中的一些核心模块，提供了一些后端编程的能力）</li>
</ol>
<h2 id="ECMAScript-规范-和-浏览器中的JS-以及-Node-中的-JS-之间的关系"><a href="#ECMAScript-规范-和-浏览器中的JS-以及-Node-中的-JS-之间的关系" class="headerlink" title="ECMAScript 规范 和 浏览器中的JS 以及 Node 中的 JS  之间的关系"></a>ECMAScript 规范 和 浏览器中的JS 以及 Node 中的 JS  之间的关系</h2><ol>
<li>ECMAScript 规范（标准）：就是一本书，这本书中记录了基本的语法定义；</li>
<li>浏览器中的 JS：浏览器中的JS是一门具体的编程语言，实现了 ECMAScript 规范；<ul>
<li>浏览器中的JS组成部分： ECMAScript 核心 + DOM + BOM</li>
</ul>
</li>
<li>Node中的JS：也是一门具体的编程语言，也实现了 ECMAScript 规范；<ul>
<li>Node中的JS组成部分： ECMAScript 核心 + 全局成员 + 模块系统成员</li>
</ul>
</li>
</ol>
<h2 id="总结-什么是-Node-js"><a href="#总结-什么是-Node-js" class="headerlink" title="总结-什么是 Node.js"></a>总结-什么是 Node.js</h2><ul>
<li>基于 Chrome 的V8 JS 解析引擎之上，解放了Javascript的编程能力，为 Javascript 提供了 后端编程的能力；</li>
<li>所以说，Node.js 是 一个后端编程的平台，用到的语言是Javascript；</li>
</ul>
<h2 id="Node-js-环境中执行JS代码的两种方式"><a href="#Node-js-环境中执行JS代码的两种方式" class="headerlink" title="Node.js 环境中执行JS代码的两种方式"></a>Node.js 环境中执行JS代码的两种方式</h2><h3 id="REPL-环境"><a href="#REPL-环境" class="headerlink" title="REPL 环境"></a>REPL 环境</h3><ol>
<li>如何进入 REPL 环境： 打开任意终端，直接输入 <code>node</code> 并回车，就会进入到 REPL 环境中；</li>
<li>如何离开 REPL 环境：按两次<code>ctrl + c</code> 就能退出 REPL 环境；</li>
<li>REPL中，每个字母代表什么意思呢：<ul>
<li>R： Read 的意思，每当我们输入完毕代码之后，只要敲击回车，Node环境就会读取用户输入的代码</li>
<li>E：Evaluate 的意思，表示把 Read 进来的用户代码，调用 类似于 Eval 的函数，去解析执行</li>
<li>P：Print 输出的意思；把第二步中解析执行的结果，输出给用户；</li>
<li>L：Loop 循环的意思，表示当输出完毕之后，进入下一次的 REP循环<h3 id="node-命令【推荐形式】"><a href="#node-命令【推荐形式】" class="headerlink" title="node 命令【推荐形式】"></a>node 命令【推荐形式】</h3></li>
</ul>
</li>
</ol>
<ul>
<li>(Node为JS提供了一个脱离浏览器平台也能被解析的执行环境)</li>
</ul>
<ul>
<li>直接使用<code>node 要执行的js文件的路径</code> 来执行指定的JS文件</li>
</ul>
<ol>
<li>使用 ↑ 快速定位到上一次执行的命令</li>
<li>使用 tab 键能够快速补全路径</li>
<li>使用 cls 可以清屏</li>
</ol>
<h2 id="ECMAScript-6常用语法"><a href="#ECMAScript-6常用语法" class="headerlink" title="ECMAScript 6常用语法"></a>ECMAScript 6常用语法</h2><h3 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h3><ul>
<li>之前定义变量，用 var 关键字，用var有没有缺点：</li>
</ul>
<ol>
<li>变量提升问题 </li>
<li>没有块级作用域</li>
</ol>
<ul>
<li>let特性：<ol>
<li>使用let关键字定义变量,不存在变量提升的问题</li>
<li>let定义的变量受到{ } 作用域的影响(有{}的作用域)</li>
<li>let有块级作用域</li>
</ol>
</li>
<li>const特性：<ol>
<li>没有变量提升的问题</li>
<li>const 定义的量叫常量,只要被定义了，无法被重新赋值</li>
<li>当定义常量的时候，必须定义且初始化，否则报语法错误<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3></li>
</ol>
</li>
</ul>
<ol>
<li>所谓的解构赋值，就是把 某个对象中的属性，当作变量，给解放出来，这样，今后就能够当作变量直接使用了</li>
<li>可以使用 <code>:</code>为解构出来的变量重命名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 变量的解构赋值</span><br><span class="line">const &#123; name : name123, age, gender &#125; = person</span><br><span class="line">console.log(name123)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ol>
<li>模板字符串</li>
</ol>
<ul>
<li>模板字符串的特点: 支持换行,可以嵌入变量的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str +=`&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;$&#123;arr[i].id&#125;&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;$&#123;arr[i].name&#125;&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;$&#123;arr[i].age&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;`</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>startsWith() 和 endsWith()<ul>
<li>startsWith() 用来判断字符串，是否以指定的字符开头，如果是，返回值是 true，否则返回 false</li>
<li>endsWith() 用来判断字符串，是否以指定的字符结尾；如果是，返回值是 true，否则返回 false</li>
</ul>
</li>
<li>padStart() 和 padEnd()</li>
</ol>
<ul>
<li>padStart()第一个参数是填充完毕之后总长度是多少;第二个参数是填充的内容<h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3></li>
</ul>
<ol>
<li><p>形参默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y = 0) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构赋值和形参默认值结合使用</p>
</li>
<li><p>rest参数(定义函数的时候使用…来定义的参数叫做rest参数,定义一个接受所有参数的数组)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ------------------rest参数-------------------</span><br><span class="line">function add(...args) &#123;</span><br><span class="line">  console.log(args instanceof Array)</span><br><span class="line"></span><br><span class="line">  let total = 0</span><br><span class="line">  args.forEach(item =&gt; &#123;</span><br><span class="line">    total += item</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2, 3, 4)</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符(在调用函数的时候,使用的…的运算符来扩展数组,…运算符称为扩展运算符)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ----------------------扩展运算符--------------</span><br><span class="line">function add(...values) &#123;</span><br><span class="line">  let total = 0</span><br><span class="line">  values.forEach(item =&gt; &#123;</span><br><span class="line">    total += item</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  console.log(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [1, 2, 3]</span><br><span class="line">add(...arr)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="箭头函数-是ES6中新增的函数形式-【今后我们会每天写箭头函数的】"><a href="#箭头函数-是ES6中新增的函数形式-【今后我们会每天写箭头函数的】" class="headerlink" title="箭头函数(是ES6中新增的函数形式)【今后我们会每天写箭头函数的】"></a>箭头函数(是ES6中新增的函数形式)【今后我们会每天写箭头函数的】</h3><ol>
<li>如何把 function 改成 箭头函数呢：  先把 function 删掉，然后，在 ()  和 { } 之间，添加一个 <code>=&gt;</code> 就好了</li>
<li>箭头函数的特性： 箭头函数内部的 this, 永远和 箭头函数外部的 this 保持一致；</li>
<li>箭头函数,本质上就是一个匿名函数 (不能直接调用)</li>
<li>最标准的箭头函数格式是      ( 参数列表 ) =&gt; { 函数体 }</li>
<li>变体1： 如果 箭头函数左侧的 形参列表中，只有一个 形参，那么，( ) 可以省略   ( x ) =&gt; { console.log(x) }     可以改造成     x =&gt; { console.log(x) }</li>
<li>变体2：如果 箭头函数右侧的 函数体中，只有一行代码，那么， { } 可以省略    (x, y) =&gt; {console.log(x + y)}  可以改造成    (x, y) =&gt; console.log(x + y)</li>
<li>变体3：如果箭头函数 左侧 只有一个形参，右侧只有一行代码，那么， 左侧的 () 和 右侧的 {} 都可以省略  ( x ) =&gt; { console.log(x) }   可以改造成     x =&gt; console.log(x)</li>
<li>注意： 如果我们省略了 右侧的 { }， 那么，默认就会把 右侧函数体中的代码执行结果，返回出去     (x, y) =&gt; { return  x + y }   可以简写成    (x, y) =&gt; x + y<h3 id="对象中定义方法和属性的便捷方式"><a href="#对象中定义方法和属性的便捷方式" class="headerlink" title="对象中定义方法和属性的便捷方式"></a>对象中定义方法和属性的便捷方式</h3></li>
</ol>
<h2 id="在Node中使用fs模块进行文件操作"><a href="#在Node中使用fs模块进行文件操作" class="headerlink" title="在Node中使用fs模块进行文件操作"></a>在Node中使用fs模块进行文件操作</h2><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  // 1. 使用require 来导入需要的模块</span><br><span class="line">  const fs = require(&apos;fs&apos;)</span><br><span class="line">  // 参数一: 要读取文件的路径</span><br><span class="line">  // 参数二: 可选参数,表示字符编码, 默认为空null</span><br><span class="line">  // 参数三: callback回调函数</span><br><span class="line">  // fs.readFile(&apos;./files/1.txt&apos;, function (err,buf)&#123;</span><br><span class="line">  // console.log(err)//null</span><br><span class="line">  // console.log(buf.toString())//Buffer是一种类型,表示二进制的意思</span><br><span class="line">  // 如果读取文件没有出错,则err默认为null,buf是读取到的二进制</span><br><span class="line">  // 可以调用buffer.toString转换为正常的字符串</span><br><span class="line"></span><br><span class="line">  // Buffer 实例和字符串拼接,得到的结果,是一个字符串</span><br><span class="line">  // console.log(buf + &apos;&apos;)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  // fs.readFile(&apos;./files/1.txt&apos;,(err,buf) =&gt; &#123;</span><br><span class="line">  // Error 实例对象中,有个message属性,表示错误信息</span><br><span class="line">  // if(err)return console.log(err.message)</span><br><span class="line">  // console.log(buf.toString())</span><br><span class="line">  // &#125;)</span><br><span class="line">  // 第二个参数可以用&apos;utf-8&apos;的编码格式,这样buf就不用转换为字符串</span><br><span class="line">  fs.readFile(&apos;./files/1.txt&apos;,&apos;utf-8&apos;,(err,dataStr) =&gt; &#123;</span><br><span class="line">    // Error 实例对象中,有个message属性,表示错误信息</span><br><span class="line">    if(err)return console.log(err.message)</span><br><span class="line">    console.log(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><ul>
<li>参数一: 文件路径</li>
<li>参数二: 要写入的数据</li>
<li>参数三: 可选的编码格式, 默认utf-8</li>
<li>参数四: 文件写入后的回调函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  const fs = require(&apos;fs&apos;)</span><br><span class="line">  // 写入文件到指定文件中去(会覆盖原来的内容)</span><br><span class="line">  fs.write(&apos;文件路径&apos;,&apos;内容&apos;,(err) =&gt; &#123;</span><br><span class="line">     // 内容的改变会覆盖上一次的上传</span><br><span class="line">    if(err) return console.log(&apos;写入失败了:&apos; + err.message)</span><br><span class="line">    console.log(&apos;写入成功了!&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">  // fs.copyFile 也可以,但它只支持8.5.0以上的版本</span><br><span class="line">  fs.copyFile(&apos;./files/1.txt&apos;&apos;./files/1-copy.txt&apos;(err) =&gt; &#123;</span><br><span class="line">    if(err) return console.log(&apos;写入文件失败:&apos; + err.message)</span><br><span class="line">    console.log(&apos;恭喜,写入成功&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文件追加"><a href="#文件追加" class="headerlink" title="文件追加"></a>文件追加</h3><ul>
<li>fs.appendFile(file,data[,option],callback)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. 导入 fs 文件系统模块</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">// 参数一: 要追加的文件的路径</span><br><span class="line">// 参数二: 要追加的数据内容</span><br><span class="line">// 第三个参数:追加时候的编码格式 默认为utf-8</span><br><span class="line">// 参数三: 追加完毕之后的回调函数</span><br><span class="line">fs.appendFile(&apos;./files/2.txt&apos;,&apos;\n降龙十八掌&apos;,(err) =&gt; &#123;</span><br><span class="line">    if(err) return console.log(&apos;写入文件失败:&apos; + err.message)</span><br><span class="line">    console.log(&apos;恭喜,写入成功&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="fs模块中路径操作问题【难点】"><a href="#fs模块中路径操作问题【难点】" class="headerlink" title="fs模块中路径操作问题【难点】"></a>fs模块中路径操作问题【难点】</h3><ul>
<li>在Node中,使用fs模块来操作文件的时候,如果我们给定的路径是一个以’./‘开头的相对路径,找文件指的是Node命令所在的目录来查找 ,所以<strong>最好使用绝对路径(拼接成绝对路径 __dirname + ‘文件名’)</strong></li>
</ul>
<ol>
<li>__dirname 表示当前文件所在的目录</li>
<li>__filename 表示当前文件的完整路径</li>
</ol>
<ul>
<li>const path = require(‘path’) const abspath = path.join(__dirname,’文件名’)来解决/的问题</li>
<li><strong>注意: 今后在使用fs模块中任意方法时只要涉及路径的操作都是用_dirname做拼接</strong></li>
</ul>
<h3 id="读取文件信息-fs-stat"><a href="#读取文件信息-fs-stat" class="headerlink" title="读取文件信息   fs.stat"></a>读取文件信息   fs.stat</h3><ul>
<li>fs.stat(path,callback)<h3 id="读取指定目录中所有文件的名称-fs-readdir"><a href="#读取指定目录中所有文件的名称-fs-readdir" class="headerlink" title="读取指定目录中所有文件的名称   fs.readdir"></a>读取指定目录中所有文件的名称   fs.readdir</h3></li>
<li>fs.readir(path[,option],callback)</li>
</ul>
<h2 id="在ES6中用path来进行路径操作"><a href="#在ES6中用path来进行路径操作" class="headerlink" title="在ES6中用path来进行路径操作"></a>在ES6中用path来进行路径操作</h2><ol>
<li>path.join([…paths])</li>
</ol>
<ul>
<li>path.join 来解决路径分隔符的问题</li>
<li>今后只要涉及到路径的拼接，推荐大家使用 path.join 方法</li>
</ul>
<ol start="2">
<li>path.sep</li>
<li>path.basename(path[, ext])</li>
<li>path.dirname(path)</li>
<li>path.extname(path)<h2 id="Javascript-是单线程的一门语言"><a href="#Javascript-是单线程的一门语言" class="headerlink" title="Javascript 是单线程的一门语言"></a>Javascript 是单线程的一门语言</h2></li>
<li>什么是单线程：用户无法主动开启子线程，对于JS的运行来说，永远是主线程在执行关键代码；</li>
<li>什么是多线程：用户可以主动开启子线程；    Thread  td = new Thread()</li>
<li>在Node中，操作文件和网络都是比较耗时的操作；</li>
</ol>
<h2 id="Node中为什么大量使用异步方法"><a href="#Node中为什么大量使用异步方法" class="headerlink" title="Node中为什么大量使用异步方法"></a>Node中为什么大量使用异步方法</h2><ol>
<li>为什么要使用 异步方法呢： 因为 异步方法，不会阻塞CPU去执行其它任务；</li>
<li>为什么在Node中不推荐使用同步呢： 因为 同步，需要一个一个执行，耗时的操作会阻碍CPU执行后续任务，因此，效率慢；</li>
</ol>
<h2 id="CommonJS-模块规范和模块的使用"><a href="#CommonJS-模块规范和模块的使用" class="headerlink" title="CommonJS 模块规范和模块的使用"></a>CommonJS 模块规范和模块的使用</h2><p>Node.js 实现了 CommonJS 模块化规范；</p>
<ol>
<li>什么是 CommonJS 规范？<ul>
<li>CommonJS 是<strong>为了实现 Javascript 的模块化</strong>，而制定的一套规范；</li>
</ul>
</li>
<li>为什么 Javascript 需要模块化？(require,exports,module)<ul>
<li>所谓的模块化,就是在一个js文件中,能够引入其他的js文件</li>
<li>浏览器中的Javascript有没有实现模块化？（在一个JS文件中，能不能引用另外JS文件中的方法）</li>
<li>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</li>
</ul>
</li>
<li>如何实现 Javascript 的模块化？<ul>
<li>为了统一大家编写模块时候的规则，方便各模块之间的依赖和调用，于是 CommonJS 规范就应运而生了。</li>
</ul>
</li>
<li>那么，CommonJS 模块化规范，到底是个什么东西？？<ul>
<li>定义了什么是模块</li>
</ul>
<ul>
<li>在NodeJs中,可以认为一个js文件就是一个模块,一个模块可以是一个js文件,也可以是由多个js文件组成的</li>
</ul>
<ul>
<li>一个JS模块中，如何引入其它的JS模块</li>
</ul>
<ul>
<li>用require引入: require(‘路径’)</li>
</ul>
<ul>
<li>一个JS模块中，如何向外暴露一些成员，供其它模块调用；</li>
</ul>
<ul>
<li><code>exports.xxx = xxxx</code></li>
<li>使用module对象去访问当前模块, <code>module.exports.xxx=xxx</code></li>
</ul>
<ul>
<li>如果没有类似于 CommonJS 的规范，行不行？</li>
<li>只有大家遵守同样的规范，才能够协作开发，方便别人，同时也方便自己；</li>
</ul>
</li>
</ol>
<h2 id="全局作用域和模块作用域"><a href="#全局作用域和模块作用域" class="headerlink" title="全局作用域和模块作用域"></a>全局作用域和模块作用域</h2><ol>
<li>每个JS文件，就是一个独立的模块，在这个JS文件中，所定义的任何方法、属性、变量、常量、对象，默认都属于模块作用域，并不会属于 全局作用域；</li>
<li>如果在某个模块内部，想为 全局的 global 作用域挂载一些属性，需要显示的调用<code>global.***</code>来挂载；<h3 id="global（全局作用域）"><a href="#global（全局作用域）" class="headerlink" title="global（全局作用域）"></a>global（全局作用域）</h3></li>
</ol>
<ul>
<li>使用global这个全局对象,会造成全局变量的污染(推荐使用CommonJS规范中定义模块化机制来向外暴露成员)<h3 id="require（模块引用）"><a href="#require（模块引用）" class="headerlink" title="require（模块引用）"></a>require（模块引用）</h3>每一个实现了 CommonJS 规范的模块，必须定义一个 require() 函数，使用这个 require 函数，就能够 很方便的导入其它 模块中的成员，供自己使用；<h3 id="exports（模块定义）"><a href="#exports（模块定义）" class="headerlink" title="exports（模块定义）"></a>exports（模块定义）</h3>每一个模块中，如果想要把自己的一些私有成员，暴露给别人使用，那么，必须实现一个 exports 对象，这个对象，将来，如果你想把自己的成员，暴露给别人使用，只需要把自己的成员，挂载到 exports 上就行了(exports默认是空对象)<h3 id="module（模块标识）"><a href="#module（模块标识）" class="headerlink" title="module（模块标识）"></a>module（模块标识）</h3>这个 module 也是Common JS 规定的，它表示一个具体的模块，也是一个对象；</li>
</ul>
<h2 id="module-exports-和-exports-的关系"><a href="#module-exports-和-exports-的关系" class="headerlink" title="module.exports 和 exports 的关系"></a>module.exports 和 exports 的关系</h2><ul>
<li>在一个模块中,默认情况下module.exports和exports是指向同一个空对象的</li>
<li>在一个模块中,在向外暴露成员的时候,永远以module.exports指向的对象为准</li>
</ul>
<h2 id="Node-中的-Javascript-由几部分组成"><a href="#Node-中的-Javascript-由几部分组成" class="headerlink" title="Node 中的 Javascript 由几部分组成"></a>Node 中的 Javascript 由几部分组成</h2><ol>
<li>ECMAScript 核心</li>
<li>全局成员</li>
<li>模块系统成员<ul>
<li>模块系统成员，根据一些区别，又可以分为三大类： 核心模块、第三方模块、用户自定义模块</li>
</ul>
</li>
</ol>
<h2 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h2><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><ol>
<li>什么是核心模块：由Node官方提供的好用的模块，叫做核心模块；只要大家在计算机中，安装了Node这个应用程序，那么，我们的计算机中就已经安装了所有的 核心模块；</li>
<li>如何使用核心模块：<code>require(&#39;核心模块标识符&#39;)</code><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3></li>
<li>什么是第三方模块：一些非官方提供的模块，叫做第三方模块；注意，第三方模块，并不在我们的计算机上，如果大家需要使用某些第三方模块，必须去一个叫做 <code>NPM</code> 的网站上搜索并下载才能使用；</li>
<li>如何使用第三方模块：<ul>
<li>先从 npm 官网上下载指定的第三方模块</li>
<li>使用 <code>require(&#39;第三方模块的名称标识符&#39;)</code>来导入这个模块</li>
<li>根据 第三方模块的 官方文档，尝试使用<h3 id="用户自定义模块"><a href="#用户自定义模块" class="headerlink" title="用户自定义模块"></a>用户自定义模块</h3></li>
</ul>
</li>
<li>什么是用户模块：程序员自己写的JS文件，就叫做 用户自定义模块；</li>
<li>如何使用用户模块：<code>require(&#39;路径标识符&#39;)</code></li>
</ol>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="什么是包"><a href="#什么是包" class="headerlink" title="什么是包"></a>什么是包</h3><ol>
<li>英文名叫做 <code>Packages</code>，包是在模块基础上更深一步的抽象，目的是：方便分发推广基于 CommonJS 规范实现的 应用程序 或 类库；</li>
<li>包可以看作是 模块、代码 和 其它资源 组合起来形成的 独立作用域；</li>
</ol>
<h3 id="定义一个包"><a href="#定义一个包" class="headerlink" title="定义一个包"></a>定义一个包</h3><ol>
<li>首先包应该是一个独立的文件夹(名字应该是英文)</li>
<li>包的文件夹里面应该有一个package.json文件</li>
<li>package.json是一个json文件,在文件里编写的代码必须符合json规范(编写一个对象,对象有三个属性: name,version, main)</li>
<li>自定义的包目录(图片)</li>
</ol>
<h3 id="规范的包结构"><a href="#规范的包结构" class="headerlink" title="规范的包结构"></a>规范的包结构</h3><ol>
<li><strong>包都要以一个单独的目录而存在</strong>；</li>
<li><strong><code>package.json</code> 必须在包的顶层目录下</strong>；</li>
<li><strong><code>package.json</code> 文件必须符合 JSON 格式，并且必须包含如下三个属性：<code>name</code>, <code>version</code>, <code>main</code></strong><ul>
<li>name:  包的名字(名字不能为中文)</li>
<li>version: 包的版本号</li>
<li>main: 表示包的入口文件</li>
</ul>
</li>
<li>二进制文件应该在<strong>bin目录</strong>下;</li>
<li>javaScript代码应该在<strong>lib目录</strong>下;</li>
<li>文档应该在<strong>doc目录</strong>下;</li>
<li>单元测试应该在<strong>test目录</strong>下;</li>
<li>Node.js对包要求并没有那么严格，只要顶层目录下有<code>package.json</code>，并<strong>符合基本规范</strong>即可;<h3 id="包描述文件-package-json"><a href="#包描述文件-package-json" class="headerlink" title="包描述文件 package.json"></a>包描述文件 package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name：包的名称，必须是唯一</span><br><span class="line">description：包的简要说明</span><br><span class="line">version：符合语义化版本识别规范的版本字符串</span><br><span class="line">keywords：关键字数据，通常用于搜索</span><br><span class="line">maintainers：维护者数组，每个元素要包含name、email、web可选字段</span><br><span class="line">contributors：贡献者数组，格式与maintainers相同。包的坐着应该是贡献者数据的第一个元素</span><br><span class="line">bugs：提交bug的地址，可以是网址或者电子邮件地址</span><br><span class="line">licenses：许可证数组，每个元素要包含type和url字段</span><br><span class="line">repositories：仓库托管地址数组，每个元素要包含type、url和path字段</span><br><span class="line">dependencies：包的依赖，一个关联数组，由包名称和版本号组成。</span><br><span class="line">devDependencies：开发依赖项，表示一个包在开发期间用到的依赖项</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="npm-的两层含义"><a href="#npm-的两层含义" class="headerlink" title="npm 的两层含义"></a>npm 的两层含义</h3><ol>
<li>NPM 是一个 第三方模块的托管网站，指的就是<code>https://www.npmjs.com/</code>；</li>
<li>NPM 是Node的包管理工具（全名叫做  Node package manager），在我们安装Node时候，就已经顺便也安装了 NPM 这个管理工具；<h3 id="安装和卸载全局包"><a href="#安装和卸载全局包" class="headerlink" title="安装和卸载全局包"></a>安装和卸载全局包</h3></li>
<li>什么是全局的包：通过  <code>npm install  包名  -g</code> 方式安装的包，都安装到了全局；一般全局的安装目录是<code>C:\Users\自己的用户文件夹\AppData\Roaming\npm</code></li>
<li>带大家演示如何安装一个全局的包：<code>npm install i5ting_toc -g</code>， 注意：这里的<code>-g</code>表示全局安装包的意思；</li>
<li>注意：一般，只有一些工具，才有全局安装的必要性；</li>
<li>如果要全局卸载某个包，比如要卸载 <code>i5ting_toc</code>了，直接运行<code>npm uninstall i5ting_toc -g</code>就可以全局卸载包了！<h3 id="安装和卸载本地包"><a href="#安装和卸载本地包" class="headerlink" title="安装和卸载本地包"></a>安装和卸载本地包</h3></li>
<li>什么是本地的包：跟着项目安装的包，叫做本地包；</li>
<li>如果拿到一个空项目，必须先初始化一个<code>package.json</code>的配置文件，<code>npm init</code>或者<code>npm init -y</code>(方便些)</li>
<li>运行<code>npm i 包名@版本号 --save</code>去安装指定的包，本地安装的包，都安装到了<code>node_modules</code>的目录下</li>
<li>如果大家用的是npm 5.x的版本，可以不指定<code>--save</code>命令，如果用的是 npm 3.x 的版本，则需要手动指定 <code>--save</code>, 同时，<code>--save</code>有缩写形式，是：<code>-S</code></li>
<li><code>package-lock.json</code>文件中记录了曾经装过的包的下载地址，方便下次直接下载包；</li>
<li>卸载本地包: <code>npm uninstall 包名 --save</code><h3 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h3></li>
<li><code>--save-dev</code>它的缩写是<code>-D</code></li>
<li>注意：<code>dependencies</code>节点，表示项目上线部署时候需要的依赖项；<code>devDependencies</code>节点，表示项目在开发阶段需要的依赖项，但是当项目要部署上线了，<code>devDependencies</code>节点中的包，就不再需要了！</li>
<li>注意：当使用<code>npm i</code>快速装包的时候，npm会检查<code>package.json</code>文件中，所有的依赖项，然后都为我们安装到项目中</li>
<li><code>--production</code> 表示只安装 <code>dependencies</code> 节点下，记录的包，不安装<code>devDependencies</code>节点下的包；当项目要上线了，才会使用<code>--production</code>命令<h3 id="解决-npm-下载慢问题"><a href="#解决-npm-下载慢问题" class="headerlink" title="解决 npm 下载慢问题"></a>解决 npm 下载慢问题</h3></li>
<li>默认，NPM在下载包的时候，连接的是国外的服务器，所以，有时候如果网速不是特别好，可能下载不下来包；此时，大家可以安装一个工具，叫做<code>nrm</code>，里面记录了好多下载NPM包的服务器地址，可以让我们方便的切换下载包时候请求的服务器；</li>
<li>运行<code>npm i nrm -g</code>（注意：只要是工具，一般都是全局 -g 安装）</li>
<li>当装完 nrm 之后，可以运行<code>nrm ls</code> 查看所有可用的服务器列表</li>
<li>可使用<code>nrm use 服务器名称</code>来切换下载包时候的服务器地址</li>
</ol>
<h2 id="构建web应用"><a href="#构建web应用" class="headerlink" title="构建web应用"></a>构建web应用</h2><p>Apache 是一个PHP的服务器，当我们把做好的网站，丢到 WWW 目录下，就能够使用 IP地址 + 端口号 访问我们的网站了；</p>
<ul>
<li>IP地址的作用，是为了表示当前网络中这台计算机唯一身份的；</li>
<li>端口号：端口号和应用程序有关联，每一个应用程序，只能独占一个端口号，不能说多个应用程序公用一个端口；<br>疑问：Node中，有没有类似于 Apache 这样的服务器软件，来提供对应的网站服务呢？注意：Node中，并没有现成的 类似于 Apache 的服务器软件，如果我们想通过Node，来对外托管一个网站的话，需要自己手写一个 类似于 Apache 的服务器；<h3 id="BS-交互模型"><a href="#BS-交互模型" class="headerlink" title="BS 交互模型"></a>BS 交互模型</h3></li>
</ul>
<ol>
<li>HTTP 协议是基于 <code>请求 - 处理 - 响应</code> 通信模型的<h3 id="实现静态资源服务器"><a href="#实现静态资源服务器" class="headerlink" title="实现静态资源服务器"></a>实现静态资源服务器</h3></li>
<li>后端路由的本质</li>
</ol>
<ul>
<li>重点理解URL(统一资源定位符)的本质<h3 id="在-Node-中使用模板引擎"><a href="#在-Node-中使用模板引擎" class="headerlink" title="在 Node 中使用模板引擎"></a>在 Node 中使用模板引擎</h3><h2 id="使用-http-核心模块-构建自己的-web-server（web服务器）"><a href="#使用-http-核心模块-构建自己的-web-server（web服务器）" class="headerlink" title="使用 http 核心模块 - 构建自己的 web server（web服务器）"></a>使用 <code>http</code> 核心模块 - 构建自己的 web server（web服务器）</h2><h3 id="理解-BS-交互模型"><a href="#理解-BS-交互模型" class="headerlink" title="理解 BS 交互模型"></a>理解 BS 交互模型</h3>B/S：表示  Browser / Server        C/S     Client / Server</li>
</ul>
<ol>
<li>什么是服务器：在网络节点中，专门对外提供资源服务的一台电脑；</li>
<li>什么是客户端：在网络节点中，专门用来消耗或呈现服务器中返回的数据的电脑；</li>
<li>什么是静态资源：像 .js ,  .css, .jpg,  .html   ；所谓的静态资源，就是无需数据交互，服务器直接把资源读取，并响应给客户端就完事儿；</li>
<li>什么是动态资源：当一些资源，服务器上并没有现成的，需要现在服务器端，做一层处理，最后把处理的结果返回给客户端，这样的资源，叫做动态资源；</li>
<li>HTTP 协议的通信模型：<code>请求 - 处理 - 响应</code>的过程；<h3 id="创建基本http服务器"><a href="#创建基本http服务器" class="headerlink" title="创建基本http服务器"></a>创建基本http服务器</h3></li>
</ol>
<ul>
<li>1.先导入Node中提供分核心模块 http : const http = require(‘http’)</li>
<li><ol start="2">
<li>创建服务器 : const server = http.createServer()</li>
</ol>
</li>
<li><ol start="3">
<li>为这个server服务器,通过on方法,绑定一个事件: server.on(‘request’,function(){<br>console.log(‘ok)<br>})</li>
</ol>
</li>
<li><ol start="4">
<li>启动服务器: server.listen(3000,function(){<br>console.log(‘通知大家,服务器已经启动’)<br>})<h3 id="解决返回内容的编码格式"><a href="#解决返回内容的编码格式" class="headerlink" title="解决返回内容的编码格式"></a>解决返回内容的编码格式</h3></li>
</ol>
</li>
<li>200 是状态码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.writeHeader(200,&#123;</span><br><span class="line">  &quot;Content-Type&quot;:&apos;text/html;chartset=utf-8&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实现静态资源服务器-1"><a href="#实现静态资源服务器-1" class="headerlink" title="实现静态资源服务器"></a>实现静态资源服务器</h3><ol>
<li>后端路由的本质</li>
</ol>
<ul>
<li>重点理解URL（统一资源定位符）的本质</li>
<li>注意: res.end()方法只接受字符串或Buffer二进制,在网络传输中内容都是以二进制进行传输的<h3 id="结合模板引擎实现动态资源服务器"><a href="#结合模板引擎实现动态资源服务器" class="headerlink" title="结合模板引擎实现动态资源服务器"></a>结合模板引擎实现动态资源服务器</h3></li>
</ul>
<h2 id="静态资源请求路径问题"><a href="#静态资源请求路径问题" class="headerlink" title="静态资源请求路径问题"></a>静态资源请求路径问题</h2><ol>
<li>在浏览器的眼中，只要是地址栏中的地址，浏览器永远把 最后一个 <code>/</code> 后面的符号，认为是文件名</li>
<li>对于服务器来说，客户端请求的 URL 资源路径只是一个 <strong>标识符</strong> 而已，URL 不一定非要对应实际的物理磁盘路径！</li>
<li>一定要区分html中书写的路径标识符 <code>../</code>    <code>./</code>  和 <code>/</code> <strong>在浏览器中</strong>代表含义！</li>
</ol>
<ul>
<li><code>/</code>   表示，直接从端口号后面，开始资源请求</li>
<li><code>./</code>  表示，在发起资源请求之前，浏览器需要先 把 URL 地址 ，和 资源路径做一层拼接</li>
<li><p><code>../</code> 表示，在发起资源请求之前，浏览器需要先 把 URL 地址 ，和 资源路径做一层拼接</p>
<h2 id="使用-nodemon-工具来自动重启web服务器"><a href="#使用-nodemon-工具来自动重启web服务器" class="headerlink" title="使用 nodemon 工具来自动重启web服务器"></a>使用 <code>nodemon</code> 工具来自动重启web服务器</h2></li>
<li>这个工具的作用：能够实时监听 web 服务器中，代码的改变，只要代码被修改并保存了，则 nodemon 工具，会自动重新启动 web 服务器；</li>
<li>运行 <code>npm i nodemon -g</code> 就能够在全局环境中，安装这个工具了</li>
<li>当安装完毕 <code>nodemon</code> 之后，就可以 使用 <code>nodemon 要执行的js文件路径</code> 来运行JS文件了</li>
<li>今后在开发Web项目的时候，推荐使用 nodemon 来执行 web 服务器</li>
</ul>
<h2 id="Node-中的-Web-快速开发框架-Express"><a href="#Node-中的-Web-快速开发框架-Express" class="headerlink" title="Node 中的 Web 快速开发框架 - Express"></a>Node 中的 Web 快速开发框架 - Express</h2><p>定义什么是Express：</p>
<ol>
<li>基于 Node.js 后端Javascript平台之上，开发出来的一套Web开发框架； </li>
<li>Express中，基于 原生Node的特性，做了进一步的封装，提供了一些更加好用的方法，来提高Web开发的体验；</li>
<li>Express中，并没有覆盖或者删除原生的http模块方法；<h3 id="express-框架的安装和基本使用"><a href="#express-框架的安装和基本使用" class="headerlink" title="express 框架的安装和基本使用"></a>express 框架的安装和基本使用</h3></li>
<li>直接运行 <code>npm install express --save</code> 就可以安装Express框架了<h3 id="使用-express-快速托管静态资源"><a href="#使用-express-快速托管静态资源" class="headerlink" title="使用 express 快速托管静态资源"></a>使用 express 快速托管静态资源</h3></li>
<li>如果我们网站中，有很多静态资源需要被外界访问，此时，使用 res.sendFile 就有点力不从心了，这时候，express 框架，为我们提供了一个 内置的（中间件）  <code>express.static(&#39;静态资源目录&#39;)</code>  ， 来快速托管指定目录下的所有静态资源文件；</li>
<li>用法： <code>app.use(express.static(&#39;public&#39;));</code></li>
</ol>
<ul>
<li>其中， <code>express.static</code> 是一个express的内置中间件；</li>
<li><code>app.use()</code>方法，是专门用来注册 中间件；</li>
</ul>
<ol start="3">
<li><p>当使用 第二步中的方法，把指定目录托管为静态资源目录之后，那么，这一层被托管的目录，不应该出现在 资源访问的 URL地址中；</p>
</li>
<li><p>在一个Web项目中，我们可以多次调用<code>app.use(express.static())</code></p>
</li>
<li><p>在多次调用 express.static 的时候，如果文件名称有重复的，则以先注册的中间件为主！</p>
</li>
<li><p>如果项目要部署了，推荐大家配置一个叫做<code>compression</code>的中间件，它能够开启服务器的GZip压缩功能；</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var compression = require(&apos;compression&apos;) app.use(compression())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="为-express-框架配置模板引擎渲染动态页面"><a href="#为-express-框架配置模板引擎渲染动态页面" class="headerlink" title="为 express 框架配置模板引擎渲染动态页面"></a>为 express 框架配置模板引擎渲染动态页面</h3><ol>
<li>安装 ejs 模板引擎<code>npm i ejs -S</code></li>
<li>使用 app.set() 配置默认的模板引擎 <code>app.set(&#39;view engine&#39;, &#39;ejs&#39;)</code></li>
<li>使用 app.set() 配置默认模板页面的存放路径 <code>app.set(&#39;views&#39;, &#39;./views&#39;)</code></li>
<li>使用 res.render() 来渲染模板页面<code>res.render(&#39;index.ejs&#39;, { 要渲染的数据对象 })</code>，注意，模板页面的 后缀名，可以省略不写！</li>
<li>使用res.send()来解决中文乱码问题<h3 id="使用-express-框架中提供的路由来分发请求"><a href="#使用-express-框架中提供的路由来分发请求" class="headerlink" title="使用 express 框架中提供的路由来分发请求"></a>使用 express 框架中提供的路由来分发请求</h3></li>
<li>什么叫做路由：前端请求的URL地址，都要对应一个后端的处理函数，那么 这种URL地址到 处理函数之间的对应关系，就叫做后端路由；</li>
<li>在Express中，路由主要负责 分发请求处理的；</li>
<li><p>在Express中，如何 定义并使用路由呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1. 封装单独的 router.js 路由模块文件</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">// 创建路由对象</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(&apos;/&apos;, (req, res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(&apos;/movie&apos;, (req, res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(&apos;/about&apos;, (req, res)=&gt;&#123;&#125;)</span><br><span class="line"></span><br><span class="line">// 导出路由对象</span><br><span class="line">module.exports = router</span><br></pre></td></tr></table></figure>
</li>
<li><p>express创建的 app 服务器，如何使用 路由模块呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 导入自己的路由模块</span><br><span class="line">const router = require(&apos;./router.js&apos;)</span><br><span class="line">// 使用 app.use() 来注册路由</span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Express-框架里-中间件的概念"><a href="#Express-框架里-中间件的概念" class="headerlink" title="Express 框架里 中间件的概念"></a>Express 框架里 中间件的概念</h2><ol>
<li>什么是中间件</li>
</ol>
<ul>
<li>中间件是一个函数</li>
<li>中间价这个函数是一个路由的处理函数</li>
<li>中间件这个函数,不但是一个路由处理函数,而且在参数列表中,还有一个很重要的形参,叫做next</li>
<li>这个next是一个函数, 因此,我们在中间件中,调用这个next()函数</li>
<li>中间件的表现形式: 只要这个函数的形参列表中,有一个next函数,它就是中间件</li>
</ul>
<ol start="2">
<li>中间件的作用是</li>
</ol>
<ul>
<li>中间件表示每一个处理环节,这些处理环节,只负责单独的处理,每当上一个中间件处理完毕后,必须把处理的原材料交给下一个中间件来继续处理</li>
<li>中间件之间,共享的是 req和res这两个对象</li>
</ul>
<ol start="3">
<li>如何注册中间件</li>
</ol>
<ul>
<li>app.use(中间件的函数)</li>
</ul>
<ol start="4">
<li>中间件里<code>next</code>函数的作用</li>
</ol>
<ul>
<li>从上一个中间件处理函数中,进入下一个中间件处理函数<h3 id="自己模拟一个解析表单数据的中间件"><a href="#自己模拟一个解析表单数据的中间件" class="headerlink" title="自己模拟一个解析表单数据的中间件"></a>自己模拟一个解析表单数据的中间件</h3></li>
</ul>
<ol>
<li>自己模拟中间件的时候，需要使用 <code>req.on(&#39;data&#39;, (chunk)=&gt;{})</code>和<code>req.on(&#39;end&#39;, ()=&gt;{})</code> 来获取表单，并使用 <code>querystring</code>模块的<code>parse</code>方法来解析成对象；</li>
<li>我们在开发中，推荐大家直接使用第三方的<code>body-parser</code>中间件来解析表单；<h3 id="Express-框架中对中间件的5种分类"><a href="#Express-框架中对中间件的5种分类" class="headerlink" title="Express 框架中对中间件的5种分类"></a>Express 框架中对中间件的5种分类</h3></li>
<li>应用级别中间件：挂载到 app 对象身上的 中间件（函数 ）</li>
<li>路由级中间件:  挂载到 router 对象上的中间件</li>
<li>错误处理中间件：参数列表中要有四个形参，从前到后分别是 <code>err</code>, <code>req</code>, <code>res</code>, <code>next</code></li>
<li>内置中间件:  Express 中唯一的内置中间件  <code>express.static(root, [options])</code></li>
<li>第三方中间件： 通过 <code>npm</code>安装的中间件，叫做 第三方中间件！</li>
</ol>
<h2 id="Express-中进行数据库操作"><a href="#Express-中进行数据库操作" class="headerlink" title="Express 中进行数据库操作"></a>Express 中进行数据库操作</h2><ol>
<li>用的数据库是MySql</li>
<li>大家是直接安装的MySql</li>
<li>安装了一个叫做 Navicat 的软件，来方便我们操作数据库<h3 id="配置-MySql-数据库环境"><a href="#配置-MySql-数据库环境" class="headerlink" title="配置 MySql 数据库环境"></a>配置 MySql 数据库环境</h3><h3 id="mysql-第三方模块的介绍和基本配置"><a href="#mysql-第三方模块的介绍和基本配置" class="headerlink" title="mysql 第三方模块的介绍和基本配置"></a>mysql 第三方模块的介绍和基本配置</h3><h3 id="使用-mysql-第三方模块实现-CRUD"><a href="#使用-mysql-第三方模块实现-CRUD" class="headerlink" title="使用 mysql 第三方模块实现 CRUD"></a>使用 mysql 第三方模块实现 CRUD</h3></li>
</ol>
<ul>
<li>C： Create</li>
<li>R： Read</li>
<li>U： Update</li>
<li>D： Delete</li>
</ul>
<h2 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h2><ol>
<li>只要使用 <code>require</code> 来加载指定的模块了，那么，必然会执行被加载模块中的代码！<h3 id="优先从缓存中加载"><a href="#优先从缓存中加载" class="headerlink" title="优先从缓存中加载"></a>优先从缓存中加载</h3></li>
<li>Node中，默认会把曾经加载过的模块，缓存到内存中，这样，当下次再使用相同的模块，就直接从缓存中加载就行了，能够提高模块的运行效率；<h3 id="核心模块的加载机制"><a href="#核心模块的加载机制" class="headerlink" title="核心模块的加载机制"></a>核心模块的加载机制</h3></li>
<li>先从缓存中查找，如果有，则直接使用；</li>
<li>如果缓存中没有，则加载本地的核心模块并缓存起来，供下次使用；<h3 id="用户模块的加载机制"><a href="#用户模块的加载机制" class="headerlink" title="用户模块的加载机制"></a>用户模块的加载机制</h3></li>
<li>先从缓存中查找，如果有，则直接使用；</li>
<li>如果缓存中没有，则根据路径标识符，加载本地的用户模块并缓存起来，供下次使用；</li>
<li>用户模块的查找规则：<code>index    -&gt;    index.js    -&gt;   index.json     -&gt;    index.node</code><h3 id="第三方模块的加载机制"><a href="#第三方模块的加载机制" class="headerlink" title="第三方模块的加载机制"></a>第三方模块的加载机制</h3></li>
<li>先从缓存中查找，如果有，则直接使用；</li>
<li>如果缓存中没有，则根据第三方模块的标识符，加载第三方模块并缓存起来，供下次使用；<h3 id="通过学习moment这个第三方模块来了解第三方模块的加载规则"><a href="#通过学习moment这个第三方模块来了解第三方模块的加载规则" class="headerlink" title="通过学习moment这个第三方模块来了解第三方模块的加载规则"></a>通过学习<code>moment</code>这个第三方模块来了解第三方模块的加载规则</h3></li>
<li>会根据包的名称，直接在当前项目的根目录中，去查找一个叫做 <code>node_modules</code> 的文件夹；</li>
<li>如果有，则在 <code>node_modules</code> 中，继续查找，一个叫做 模块引用名称的文件夹；</li>
<li>如果有，则 在 模块对应的文件夹中，查找一个叫做 <code>package.json</code> 的文件；</li>
<li>如果有 <code>package.json</code>， 则查找 其中的 <code>main</code> 属性，并尝试加载 main 指定的文件作为入口；</li>
<li>如果能正常加载 <code>main</code> 属性中指定的文件，则模块/包加载成功！</li>
<li>如果 在 <code>package.json</code> 文件中，没有 main 属性，则会依次尝试加载 包根目录中的 <code>index.js</code>, <code>index.json</code>, <code>index.node</code></li>
<li>如果在 包的根目录中，根本没有 <code>package.json</code> 文件，或者 在 node_modules 目录中没有 index 相关的文件，或者，根本没有对应的包文件夹，或者在项目根目录中根本没有<code>node_modules</code>, 则会向上层目录中，去查找<code>node_modules</code>， 查找规则同上；</li>
<li>如果在上一层目录中还是没有找到对应的模块，则继续向上翻，直到翻到项目所在的磁盘根目录位置；</li>
<li>如果翻到了磁盘的根目录中，还没有找到，此时，会报错！<code>cannot find module ***</code><h2 id="express中获取参数的几种形式"><a href="#express中获取参数的几种形式" class="headerlink" title="express中获取参数的几种形式"></a>express中获取参数的几种形式</h2><h3 id="从URL地址中获取查询参数"><a href="#从URL地址中获取查询参数" class="headerlink" title="从URL地址中获取查询参数"></a>从URL地址中获取查询参数</h3>通过 URL 地址栏中，? 形式传递的参数，可以直接通过 <code>req.query</code> 来获取；<h3 id="从URL地址中获取路径参数"><a href="#从URL地址中获取路径参数" class="headerlink" title="从URL地址中获取路径参数"></a>从URL地址中获取路径参数</h3>直接通过路径标识符来传递参数，<code>/userinfo/10/zs</code>， 可以通过 <code>req.params</code>来获取参数<h3 id="从post表单中获取提交的数据"><a href="#从post表单中获取提交的数据" class="headerlink" title="从post表单中获取提交的数据"></a>从post表单中获取提交的数据</h3></li>
</ol>
<ul>
<li>借助于<code>body-parser</code>来解析表单数据</li>
<li><code>npm i body-parser -S</code></li>
<li><code>const bodyParser = require(&#39;body-parser&#39;)</code></li>
<li><code>app.use(bodyParser.urlencoded({ extended: false }))</code></li>
</ul>
<h2 id="Web-开发模式"><a href="#Web-开发模式" class="headerlink" title="Web 开发模式"></a>Web 开发模式</h2><h3 id="混合模式（传统开发模式）"><a href="#混合模式（传统开发模式）" class="headerlink" title="混合模式（传统开发模式）"></a>混合模式（传统开发模式）</h3><ul>
<li>以后端程序员为主，基本上不需要前端程序员，或者，前端程序员只负责画页面、美化样式、写JS特效，前端程序员不需要进行数据的交互；</li>
<li>这种开发模式，在前几年比较常见；</li>
<li>他们用的最多的是 Jquery + 模板引擎</li>
<li>后端页面 .php   .jsp   .aspx   .cshtml<h3 id="前后端分离（趋势）"><a href="#前后端分离（趋势）" class="headerlink" title="前后端分离（趋势）"></a>前后端分离（趋势）</h3></li>
<li>后端负责操作数据库、给前端暴露接口</li>
<li>前端负责调用接口，渲染页面、前端就可以使用一些流行的前端框架 Vue， React， Angular</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>后端项目运行地址：<a href="http://127.0.0.1:5000" target="_blank" rel="noopener">http://127.0.0.1:5000</a></li>
<li>前端项目运行地址：<a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a></li>
<li>前后端分离开发模式的注意点：<ul>
<li>跨域问题</li>
<li>如果不考虑 表单的 Post 提交，则 可以使用 JSONP的形式来请求接口</li>
<li>但是，我们的项目中，涉及到了 英雄表单的 提交，表单提交一般都是Post</li>
<li>经过分析，由于JSONP，不支持Post，所以，我们的后端接口，无法设计成JSONP的接口；</li>
</ul>
</li>
</ol>
<h2 id="JSONP-和-CORS-的区别"><a href="#JSONP-和-CORS-的区别" class="headerlink" title="JSONP 和 CORS 的区别"></a>JSONP 和 CORS 的区别</h2><ol>
<li>JSONP的原理：动态创建script标签；<ul>
<li>JSONP发送的不是Ajax请求</li>
<li>不支持 Post 请求；</li>
</ul>
</li>
<li>CORS中文意思是<code>跨域资源共享</code> , 本质，就是使用 XHR 对象，发送Ajax请求，来进行跨域的资源共享；<ul>
<li>CORS 发送的是真正的Ajax请求</li>
<li>CORS 支持Ajax的跨域</li>
<li>如果要启用 CORS 跨域资源共享，关键在于 服务器端，只要 服务器支持CORS跨域资源共享，则 浏览器肯定能够正常访问 这种 CORS 接口；而且，客户端在 发送 Ajax的时候，就像发送普通AJax一样，没有任何代码上的变化；</li>
</ul>
</li>
<li>对于Node来说，如果想要开启 CORS 跨域通信，只需要安装<code>cors</code>的模块即可；<h2 id="HTTP协议的无状态性"><a href="#HTTP协议的无状态性" class="headerlink" title="HTTP协议的无状态性"></a>HTTP协议的无状态性</h2></li>
<li>HTTP协议的通信模型：基于<code>请求 - 处理 - 响应</code>的！</li>
<li>由于这个通信协议的关系，导致了HTTP每个请求之间都是没有关联的，每当一个请求完成之后，服务器就忘记之前谁曾经请求过！</li>
<li>如果纯粹基于HTTP通信模型，是无法完成登录状态保持的！每次请求服务器，服务器都会把这个请求当作新请求来处理！</li>
<li>我们可以通过 cookie 技术，实现状态保持，但是由于cookie是存储在客户端的一门技术，所以安全性几乎没有，因此不要使用cookie存储敏感的数据！</li>
</ol>
<h2 id="cookie介绍"><a href="#cookie介绍" class="headerlink" title="cookie介绍"></a>cookie介绍</h2><h3 id="什么是cookie，作用是什么"><a href="#什么是cookie，作用是什么" class="headerlink" title="什么是cookie，作用是什么"></a>什么是cookie，作用是什么</h3><ul>
<li>由于<strong>Http协议是无状态</strong>的，且传统服务器<strong>只能被动的响应请求</strong>，所以，当服务器获取到请求的时候，并不知道当前请求属于哪个客户端！</li>
<li>服务器为了能够明确区分每个客户端，需要使用一些小技术，来根据不同的请求区分不同的客户端；</li>
<li>只要有请求发生，那么必然对应一个客户端，那么，我们可以在每次客户端发起请求的时候，向服务器自动发送一个标识符，告诉服务器当前是哪个客户端正在请求服务器的数据；</li>
<li>如何提供这个标识符呢？我们可以在请求头(Request Headers)中添加一个标签，叫做<code>cookie</code>，这样，每次发送请求，都会把这个cookie随同其他报文一起发送给服务器，服务器可以根据报文中的cookie，区分不同的客户端浏览器。</li>
<li>如何在客户端请求头中添加标识符？<ul>
<li>在Node中可以在<code>writeHeader</code>的时候，通过<code>Set-Cookie</code>来将cookie标识通过响应报文发送给客户端！</li>
<li>客户端也可以通过一些方式来操作自己的cookie，比如通过<code>jquery.cookie</code>这个插件！</li>
</ul>
</li>
</ul>
<h3 id="cookie的基本使用"><a href="#cookie的基本使用" class="headerlink" title="cookie的基本使用"></a>cookie的基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function (req, res) &#123;</span><br><span class="line">    // 解析cookie</span><br><span class="line">    var cookies = &#123;&#125;;</span><br><span class="line">    var cookieStr = req.headers.cookie; // 从请求的headers中获取cookie信息</span><br><span class="line">    cookieStr &amp;&amp; cookieStr.split(&apos;;&apos;).forEach(function (item) &#123;</span><br><span class="line">        var parts = item.split(&apos;=&apos;);</span><br><span class="line">        cookies[parts[0].trim()] = parts[1].trim(); // 将cookie解析出来，保存到对象中</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.writeHeader(200, &#123;</span><br><span class="line">        &apos;Content-Type&apos;: &apos;text/plain; charset=utf-8&apos;,</span><br><span class="line">        &quot;Set-Cookie&quot;: [&apos;issend=ok&apos;, &apos;age=20&apos;]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if(cookies.issend ===&apos;ok&apos;)&#123;</span><br><span class="line">        res.end(&apos;不要太贪心哦！&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.end(&apos;呐，赏你一朵小红花~~&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(4000, function () &#123;</span><br><span class="line">    console.log(&apos;服务器已启动!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="通过expires设置Cookie的过期时间"><a href="#通过expires设置Cookie的过期时间" class="headerlink" title="通过expires设置Cookie的过期时间"></a>通过<code>expires</code>设置Cookie的过期时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设置 过期时间 为60秒之后</span><br><span class="line">// 注意：在设置过期时间的时候，需要将时间转换为 UTC 格式</span><br><span class="line">var expiresTime = new Date(Date.now() + 1000 * 60).toUTCString();</span><br><span class="line">res.writeHeader(200, &#123;</span><br><span class="line">  &apos;Content-Type&apos;: &apos;text/html; charset=utf-8&apos;,</span><br><span class="line">  &apos;Set-Cookie&apos;: [&apos;isvisit=true;expires=&apos; + expiresTime, &apos;test=OK&apos;]</span><br><span class="line">&#125;);</span><br><span class="line">res.end(&apos;&lt;h3&gt;你好，欢迎光临，送给你一个苹果！&lt;/h3&gt;&apos;);</span><br></pre></td></tr></table></figure>
<p><a href="http://www.wbiao.cn/cartier-watches/knowledge/article-1468.html" target="_blank" rel="noopener">GMT和UTC有什么区别？格林尼治标准时（GMT）与世界时（UTC）是怎么回事</a></p>
<h3 id="cookie可以被伪造，不安全"><a href="#cookie可以被伪造，不安全" class="headerlink" title="cookie可以被伪造，不安全"></a>cookie可以被伪造，不安全</h3><p>使用谷歌插件<code>edit this cookie</code>，就能伪造cookie数据！所以不要使用cookie存储敏感的数据！比如登录状态和登录信息；<br>一些敏感的数据，应该存储都服务器端！</p>
<h3 id="什么是Cookie的应用场景"><a href="#什么是Cookie的应用场景" class="headerlink" title="什么是Cookie的应用场景"></a>什么是Cookie的应用场景</h3><ol>
<li>对安全性要求不高</li>
<li>不需要存储大量的数据</li>
<li>主要应用场景，是用来做 客户端 与 服务器之间的 状态保持技术；</li>
</ol>
<h3 id="使用express-session来保存登录状态"><a href="#使用express-session来保存登录状态" class="headerlink" title="使用express-session来保存登录状态"></a>使用<code>express-session</code>来保存登录状态</h3><h4 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h4><p>由于HTTP是无状态的，所以服务器在每次连接中持续保存客户端的私有数据，此时需要结合cookie技术，通过session会话机制，在服务器端保存每个HTTP请求的私有数据；</p>
<h4 id="session原理"><a href="#session原理" class="headerlink" title="session原理"></a>session原理</h4><p>在服务器内存中开辟一块地址空间，专门存放每个客户端私有的数据，每个客户端根据cookie中保存的私有sessionId，可以获取到独属于自己的session数据。</p>
<h4 id="在express中使用session"><a href="#在express中使用session" class="headerlink" title="在express中使用session"></a>在express中使用session</h4><ol>
<li><p>安装session模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-session -S</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入session模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var session = require(&apos;express-session&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在express中使用<code>session</code>中间件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 启用 session 中间件</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: &apos;keyboard cat&apos;, // 相当于是一个加密密钥，值可以是任意字符串</span><br><span class="line">  resave: false, // 强制session保存到session store中</span><br><span class="line">  saveUninitialized: false // 强制没有“初始化”的session保存到storage中</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
</li>
<li><p>将私有数据保存到当前请求的session会话中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将登录的用户保存到session中</span><br><span class="line">req.session.user = result.dataValues;</span><br><span class="line">// 设置是否登录为true</span><br><span class="line">req.session.islogin = true;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>destroy()</code>方法清空<code>session</code>数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">req.session.destroy(function(err)&#123;</span><br><span class="line">  if(err) throw err;</span><br><span class="line">  console.log(&apos;用户退出成功！&apos;);</span><br><span class="line">  // 实现服务器端的跳转，这个对比于 客户端跳转</span><br><span class="line">  res.redirect(&apos;/&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol>
<li><a href="http://blog.csdn.net/liangklfang/article/details/50998959" target="_blank" rel="noopener">node.js中express-session配置项详解</a></li>
<li><a href="http://www.cmd5.com/" target="_blank" rel="noopener">MD5在线生成器1</a></li>
<li><a href="http://pmd5.com/" target="_blank" rel="noopener">MD5在线生成器2</a></li>
<li><a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">JavaScript-MD5</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/11/node-js/" data-id="cjkg9cxex0005jsv7jscbobmz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/27/GitHub/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          GitHub
        
      </div>
    </a>
  
  
    <a href="/2018/07/05/JavaScript-summarize/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JavaScript-summarize</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/05/Flex/">Flex</a>
          </li>
        
          <li>
            <a href="/2018/07/27/GitHub/">GitHub</a>
          </li>
        
          <li>
            <a href="/2018/07/11/node-js/">node.js</a>
          </li>
        
          <li>
            <a href="/2018/07/05/JavaScript-summarize/">JavaScript-summarize</a>
          </li>
        
          <li>
            <a href="/2018/07/01/Cmd-Markdown/">Cmd-Markdown</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>