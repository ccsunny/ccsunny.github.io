<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Cecilia</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Flex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/05/Flex/" class="article-date">
  <time datetime="2018-08-05T01:11:47.000Z" itemprop="datePublished">2018-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/05/Flex/">Flex</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CSS伸缩布局📕"><a href="#CSS伸缩布局📕" class="headerlink" title="CSS伸缩布局📕"></a>CSS伸缩布局📕</h1><hr>
<h2 id="Flex布局是什么❓"><a href="#Flex布局是什么❓" class="headerlink" title="Flex布局是什么❓"></a>Flex布局是什么❓</h2><ul>
<li>Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</li>
</ul>
<ul>
<li><p>任何一个容器都可以指定为Flex布局。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>行内元素也可以使用Flex布局。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Webkit内核的浏览器，必须加上-webkit前缀。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: -webkit-flex; /* Safari */</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><strong>注意</strong>，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</li>
<li>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</li>
<li>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</li>
</ul>
<h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><ul>
<li>以下6个属性设置在容器上<ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
</li>
</ul>
<ol>
<li>flex-direction属性</li>
</ol>
<ul>
<li><p>flex-direction属性决定主轴的方向（即项目的排列方向）。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-direction: row | row-reverse | column |  column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它可能有4个值</p>
<ul>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>flex-wrap属性</li>
</ol>
<ul>
<li><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它可能取三个值。</p>
<ul>
<li>nowrap（默认）：不换行。</li>
<li>wrap：换行，第一行在上方。</li>
<li>wrap-reverse：换行，第一行在下方。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>flex-flow</li>
</ol>
<ul>
<li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li>justify-content属性</li>
</ol>
<ul>
<li><p>justify-content属性定义了项目在主轴上的对齐方式。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  justify-content: flex-start | flex-end | center |     space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>align-items属性</li>
</ol>
<ul>
<li><p>align-items属性定义项目在交叉轴上如何对齐。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-items: flex-start | flex-end | center |     baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<ul>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>align-content属性</li>
</ol>
<ul>
<li><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  align-content: flex-start | flex-end | center |   space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该属性可能取6个值。</p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间 的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。<h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2></li>
</ul>
</li>
<li>以下6个属性设置在项目上。<ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
</li>
</ul>
<ol>
<li>order属性</li>
</ol>
<ul>
<li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  order: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>flex-grow属性</li>
</ol>
<ul>
<li><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-grow: &lt;number&gt;; /* default 0 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
</li>
</ul>
<ol start="3">
<li>flex-shrink属性</li>
</ol>
<ul>
<li><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-shrink: &lt;number&gt;; /* default 1 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
</li>
<li>负值对该属性无效。</li>
</ul>
<ol start="4">
<li>flex-basis属性</li>
</ol>
<ul>
<li><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: &lt;length&gt; | auto; /* default auto */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
</li>
</ul>
<ol start="5">
<li>flex属性</li>
</ol>
<ul>
<li><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? ||  &lt;&apos;flex-basis&apos;&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
</li>
<li>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</li>
</ul>
<ol start="6">
<li>align-self属性</li>
</ol>
<ul>
<li><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: auto | flex-start | flex-end | center |    baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
</li>
</ul>
<hr>
<p>👏👏👏 小编有话讲:<br>以上只是小编的浅见,如果有误,欢迎提意见@小编😊❤️</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/05/Flex/" data-id="cjkg9cxen0002jsv7017mf8nb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GitHub" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/27/GitHub/" class="article-date">
  <time datetime="2018-07-27T03:22:57.000Z" itemprop="datePublished">2018-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/27/GitHub/">GitHub</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="GitHub的相关内容✍️"><a href="#GitHub的相关内容✍️" class="headerlink" title="GitHub的相关内容✍️"></a>GitHub的相关内容✍️</h1><p>相关博客: 🙆🕮</p>
<h4 id="WordPress-Cecilia"><a href="#WordPress-Cecilia" class="headerlink" title="WordPress-Cecilia"></a><a href="http://47.98.144.147:9019" target="_blank" rel="noopener">WordPress-Cecilia</a></h4><hr>
<p><strong>GitHub</strong> 是一个面向开源及私有软件项目的托管平台,是使用 git 分布式版本控制系统.下面是我的一些学习总结: </p>
<h3 id="常用辅助命令"><a href="#常用辅助命令" class="headerlink" title="常用辅助命令"></a>常用辅助命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查看提交日志</span><br><span class="line">$ git log -3 --------查看最近三次提交的记录</span><br><span class="line"></span><br><span class="line">// 查看文件提交状态</span><br><span class="line">$ git status</span><br></pre></td></tr></table></figure>
<h3 id="常用的分支命令"><a href="#常用的分支命令" class="headerlink" title="常用的分支命令"></a>常用的分支命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 查看当前所有分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># * dev ---- 当前分支</span><br><span class="line"># master ---- 主分支</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 创建分支</span><br><span class="line">$ git branch dev</span><br><span class="line"></span><br><span class="line">// 切换分支</span><br><span class="line">$ git checkout dev</span><br><span class="line"></span><br><span class="line">// 创建并切换分支（相当于前两步操作）</span><br><span class="line">$ git checkout -b dev</span><br><span class="line"></span><br><span class="line">// 合并分支</span><br><span class="line">$ git merge dev ------ ⚠️ （此命令为：合并某分支到当前分支，例：将dev合并到master），则当前所处于master分支。</span><br><span class="line"></span><br><span class="line">// 删除指定分支</span><br><span class="line">$ git branch -D dev ------ ⚠️（保证当前分支为非删除分支</span><br></pre></td></tr></table></figure>
<h3 id="设置静态资源的预览"><a href="#设置静态资源的预览" class="headerlink" title="设置静态资源的预览"></a>设置静态资源的预览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建gh-pages分支(此分支的名字只能是gh-pages)</span><br><span class="line">$ git branch gh-pages</span><br><span class="line"></span><br><span class="line">// 切换到此分支</span><br><span class="line">$ git checkout gh-pages</span><br><span class="line"></span><br><span class="line">// 提交远程(完成)</span><br><span class="line">$ git push origin gh-pages</span><br></pre></td></tr></table></figure>
<h3 id="🖊️补充-怎么找回不小心删除的文件-在本地仓库中"><a href="#🖊️补充-怎么找回不小心删除的文件-在本地仓库中" class="headerlink" title="🖊️补充: 怎么找回不小心删除的文件(在本地仓库中):"></a>🖊️补充: 怎么找回不小心删除的文件(在本地仓库中):</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查看当前状态</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line">// 重置</span><br><span class="line">$ git reset head index.html</span><br><span class="line"></span><br><span class="line">// 切回</span><br><span class="line">$ git checkout index.html</span><br></pre></td></tr></table></figure>
<hr>
<p>👏👏👏 小编有话讲:<br>更多相关内容请关注我的博客呦,有什么不懂和有问题的也可以@小编😊❤️</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/27/GitHub/" data-id="cjkg9cxep0003jsv7553e0stb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-node-js" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/11/node-js/" class="article-date">
  <time datetime="2018-07-11T12:37:37.000Z" itemprop="datePublished">2018-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/11/node-js/">node.js</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="node-js阶段总结"><a href="#node-js阶段总结" class="headerlink" title="node.js阶段总结"></a>node.js阶段总结</h1><hr>
<h2 id="什么是前端和后端"><a href="#什么是前端和后端" class="headerlink" title="什么是前端和后端"></a>什么是前端和后端</h2><h3 id="后端的主要工作"><a href="#后端的主要工作" class="headerlink" title="后端的主要工作"></a>后端的主要工作</h3><ol>
<li>后端为前端程序员暴露API接口；</li>
<li>后端也要操作数据库；</li>
<li>优化后端业务的性能；<h3 id="前端的主要工作"><a href="#前端的主要工作" class="headerlink" title="前端的主要工作"></a>前端的主要工作</h3></li>
<li>绘制网页的页面（HTML）</li>
<li>写CSS样式美化页面、写JS做网页交互（更多的是网页的特效）</li>
<li>借助于 XHR（$.ajax   $.get   $.post）请求后端的接口；实现前后端分离开发</li>
<li>使用前端的（框架）去完成界面的开发</li>
<li>总结：前端的主要工作：用户能看到的东西，基本上都是前端做出来；<h3 id="前后端协作流程"><a href="#前后端协作流程" class="headerlink" title="前后端协作流程"></a>前后端协作流程</h3></li>
</ol>
<ul>
<li>将来进入工作，大家会接触到【前后端分离开发】；</li>
<li>协作开发的流程：后端为我们暴露数据接口，前端单纯的调用后端接口；</li>
<li>在当前Node阶段中，我们学习的是 后端开发；</li>
<li>在Node阶段，我们主要教大家如何写后端的接口；</li>
</ul>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="LTS-和-Current-版本区别"><a href="#LTS-和-Current-版本区别" class="headerlink" title="LTS 和 Current 版本区别"></a>LTS 和 Current 版本区别</h3><ol>
<li>LTS 是长期稳定版的意思（这个安装包用起来比较稳定）【推荐在企业中使用】</li>
<li>Current 是最新特征版，这个安装包中有最新的Node特性，但是，可能有一些潜藏的Bug未解决；【推荐学习或尝鲜去使用】<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><h4 id="查看-Node-版本号"><a href="#查看-Node-版本号" class="headerlink" title="查看 Node 版本号"></a>查看 Node 版本号</h4>打开终端，在命令行输入命令<code>node -v</code>即可<br>如何进入终端呢？</li>
<li>使用快捷键<code>windows徽标 + R</code>打开运行面板，输入 <code>cmd</code> 后直接回车；</li>
<li>在任意目录的空白位置，先按住<code>shift</code>键不松开，然后，在空白位置，鼠标右键单击，会出来一个右键菜单，选择<code>在此处打开 powershell/cmd 窗口</code>【将来第二种方式用的会多一些】<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><h4 id="什么是环境变量"><a href="#什么是环境变量" class="headerlink" title="什么是环境变量"></a>什么是环境变量</h4>Path环境变量的作用：能够让我们通过命令行的形式，快速启动一些应用程序；<h4 id="系统环境变量和用户环境变量的区别"><a href="#系统环境变量和用户环境变量的区别" class="headerlink" title="系统环境变量和用户环境变量的区别"></a>系统环境变量和用户环境变量的区别</h4></li>
<li>用户环境变量，是每个用户私有的，用户之间不会共享；</li>
<li>全局环境变量，是共享的，只要你能登录这台计算机，就能访问到全局的环境变量；【今后在配置环境变量的时候，推荐直接配置到系统环境变量】<h4 id="通过命令行快速启动应用程序时，路径的查找规则"><a href="#通过命令行快速启动应用程序时，路径的查找规则" class="headerlink" title="通过命令行快速启动应用程序时，路径的查找规则"></a>通过命令行快速启动应用程序时，路径的查找规则</h4></li>
<li>先在当前 cmd 终端的目录中查找，如果有则直接运行；</li>
<li>如果当前目录中没有，则去全局的path环境变量中查找；</li>
</ol>
<h2 id="浏览器中的-JavaScript"><a href="#浏览器中的-JavaScript" class="headerlink" title="浏览器中的 JavaScript"></a>浏览器中的 JavaScript</h2><h3 id="Javascript的诞生"><a href="#Javascript的诞生" class="headerlink" title="Javascript的诞生"></a>Javascript的诞生</h3><ol>
<li>JS 诞生 和 网景公司 有关；form</li>
<li>JS 诞生的需求，就是为了做客户端表单验证的；</li>
<li>JS作者刚把JS创建出来之后，它叫 LiveScript  -&gt;   Javascript<h3 id="浏览器一战"><a href="#浏览器一战" class="headerlink" title="浏览器一战"></a>浏览器一战</h3>主角是 IE 和 网景浏览器；</li>
<li>一战的果实：ECMAScript 规范的确立！</li>
<li>短暂的和平期：在和平期阶段，JS都在做什么事情呢（进行表单的验证、做简单的网页动效、狗皮膏药），一战之后，JS能力有限，当时被称作是“脚本语言”<h3 id="浏览器二战"><a href="#浏览器二战" class="headerlink" title="浏览器二战"></a>浏览器二战</h3></li>
</ol>
<ul>
<li>在 2008 年，二战开始了；</li>
<li>谷歌chrome、IE、火狐（浴火重生）</li>
<li>在 2008 年，谷歌 利用 XHR 这个对象，实现了网页的局部刷新；</li>
<li>2010 - 2013年左右，公司中，不管是Java，还是.NET, 还是 PHP（会不会Ajax）</li>
</ul>
<ol>
<li>二战的果实：XHR 对象的诞生； chrome 浏览器的 JS V8 解析引擎；<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3></li>
</ol>
<ul>
<li>在 一战 和 二战期间，JS 只能运行在 浏览器中；<br>浏览器中的JS组成部分：ECMAScript核心 + DOM + BOM<br>浏览器属于前端环境，所以，之前的JS只运行在前端浏览器中；也就是，无法使用Javascript实现后端编程；</li>
</ul>
<h2 id="Node中的Javascript"><a href="#Node中的Javascript" class="headerlink" title="Node中的Javascript"></a>Node中的Javascript</h2><ul>
<li>Node.js 的诞生，解放了Javascript，从此之后，Javascript 就可以在 服务器端运行了；<h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3></li>
<li>Node中的Javascript也有一个ECMAScript核心<h3 id="没有-BOM-和-DOM"><a href="#没有-BOM-和-DOM" class="headerlink" title="没有 BOM 和 DOM"></a>没有 BOM 和 DOM</h3></li>
<li>Node中并没有浏览器的概念，所以，BOM和 DOM ，Node中不需要，因此，就把它们给剔除了；<h3 id="全局成员-网页和Node中都可以用"><a href="#全局成员-网页和Node中都可以用" class="headerlink" title="全局成员(网页和Node中都可以用)"></a>全局成员(网页和Node中都可以用)</h3></li>
</ul>
<ol>
<li>console</li>
<li>setInterval</li>
<li>setTimeout</li>
<li>…其它全局成员<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3></li>
<li>Node中自己扩展出来的一套API规范<h3 id="Node中的JS组成部分"><a href="#Node中的JS组成部分" class="headerlink" title="Node中的JS组成部分"></a>Node中的JS组成部分</h3></li>
</ol>
<ul>
<li>ECMAScript核心 + 全局成员 + 模块系统成员（这是Node平台所独有的）</li>
</ul>
<ol>
<li>全局成员（console.log,   setTimeout  setInterval）</li>
<li>模块系统成员（就是Node中的一些核心模块，提供了一些后端编程的能力）</li>
</ol>
<h2 id="ECMAScript-规范-和-浏览器中的JS-以及-Node-中的-JS-之间的关系"><a href="#ECMAScript-规范-和-浏览器中的JS-以及-Node-中的-JS-之间的关系" class="headerlink" title="ECMAScript 规范 和 浏览器中的JS 以及 Node 中的 JS  之间的关系"></a>ECMAScript 规范 和 浏览器中的JS 以及 Node 中的 JS  之间的关系</h2><ol>
<li>ECMAScript 规范（标准）：就是一本书，这本书中记录了基本的语法定义；</li>
<li>浏览器中的 JS：浏览器中的JS是一门具体的编程语言，实现了 ECMAScript 规范；<ul>
<li>浏览器中的JS组成部分： ECMAScript 核心 + DOM + BOM</li>
</ul>
</li>
<li>Node中的JS：也是一门具体的编程语言，也实现了 ECMAScript 规范；<ul>
<li>Node中的JS组成部分： ECMAScript 核心 + 全局成员 + 模块系统成员</li>
</ul>
</li>
</ol>
<h2 id="总结-什么是-Node-js"><a href="#总结-什么是-Node-js" class="headerlink" title="总结-什么是 Node.js"></a>总结-什么是 Node.js</h2><ul>
<li>基于 Chrome 的V8 JS 解析引擎之上，解放了Javascript的编程能力，为 Javascript 提供了 后端编程的能力；</li>
<li>所以说，Node.js 是 一个后端编程的平台，用到的语言是Javascript；</li>
</ul>
<h2 id="Node-js-环境中执行JS代码的两种方式"><a href="#Node-js-环境中执行JS代码的两种方式" class="headerlink" title="Node.js 环境中执行JS代码的两种方式"></a>Node.js 环境中执行JS代码的两种方式</h2><h3 id="REPL-环境"><a href="#REPL-环境" class="headerlink" title="REPL 环境"></a>REPL 环境</h3><ol>
<li>如何进入 REPL 环境： 打开任意终端，直接输入 <code>node</code> 并回车，就会进入到 REPL 环境中；</li>
<li>如何离开 REPL 环境：按两次<code>ctrl + c</code> 就能退出 REPL 环境；</li>
<li>REPL中，每个字母代表什么意思呢：<ul>
<li>R： Read 的意思，每当我们输入完毕代码之后，只要敲击回车，Node环境就会读取用户输入的代码</li>
<li>E：Evaluate 的意思，表示把 Read 进来的用户代码，调用 类似于 Eval 的函数，去解析执行</li>
<li>P：Print 输出的意思；把第二步中解析执行的结果，输出给用户；</li>
<li>L：Loop 循环的意思，表示当输出完毕之后，进入下一次的 REP循环<h3 id="node-命令【推荐形式】"><a href="#node-命令【推荐形式】" class="headerlink" title="node 命令【推荐形式】"></a>node 命令【推荐形式】</h3></li>
</ul>
</li>
</ol>
<ul>
<li>(Node为JS提供了一个脱离浏览器平台也能被解析的执行环境)</li>
</ul>
<ul>
<li>直接使用<code>node 要执行的js文件的路径</code> 来执行指定的JS文件</li>
</ul>
<ol>
<li>使用 ↑ 快速定位到上一次执行的命令</li>
<li>使用 tab 键能够快速补全路径</li>
<li>使用 cls 可以清屏</li>
</ol>
<h2 id="ECMAScript-6常用语法"><a href="#ECMAScript-6常用语法" class="headerlink" title="ECMAScript 6常用语法"></a>ECMAScript 6常用语法</h2><h3 id="let-与-const"><a href="#let-与-const" class="headerlink" title="let 与 const"></a>let 与 const</h3><ul>
<li>之前定义变量，用 var 关键字，用var有没有缺点：</li>
</ul>
<ol>
<li>变量提升问题 </li>
<li>没有块级作用域</li>
</ol>
<ul>
<li>let特性：<ol>
<li>使用let关键字定义变量,不存在变量提升的问题</li>
<li>let定义的变量受到{ } 作用域的影响(有{}的作用域)</li>
<li>let有块级作用域</li>
</ol>
</li>
<li>const特性：<ol>
<li>没有变量提升的问题</li>
<li>const 定义的量叫常量,只要被定义了，无法被重新赋值</li>
<li>当定义常量的时候，必须定义且初始化，否则报语法错误<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3></li>
</ol>
</li>
</ul>
<ol>
<li>所谓的解构赋值，就是把 某个对象中的属性，当作变量，给解放出来，这样，今后就能够当作变量直接使用了</li>
<li>可以使用 <code>:</code>为解构出来的变量重命名<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 变量的解构赋值</span><br><span class="line">const &#123; name : name123, age, gender &#125; = person</span><br><span class="line">console.log(name123)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ol>
<li>模板字符串</li>
</ol>
<ul>
<li>模板字符串的特点: 支持换行,可以嵌入变量的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str +=`&lt;tr&gt;</span><br><span class="line">      &lt;td&gt;$&#123;arr[i].id&#125;&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;$&#123;arr[i].name&#125;&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;$&#123;arr[i].age&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;`</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>startsWith() 和 endsWith()<ul>
<li>startsWith() 用来判断字符串，是否以指定的字符开头，如果是，返回值是 true，否则返回 false</li>
<li>endsWith() 用来判断字符串，是否以指定的字符结尾；如果是，返回值是 true，否则返回 false</li>
</ul>
</li>
<li>padStart() 和 padEnd()</li>
</ol>
<ul>
<li>padStart()第一个参数是填充完毕之后总长度是多少;第二个参数是填充的内容<h3 id="函数扩展"><a href="#函数扩展" class="headerlink" title="函数扩展"></a>函数扩展</h3></li>
</ul>
<ol>
<li><p>形参默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y = 0) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解构赋值和形参默认值结合使用</p>
</li>
<li><p>rest参数(定义函数的时候使用…来定义的参数叫做rest参数,定义一个接受所有参数的数组)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ------------------rest参数-------------------</span><br><span class="line">function add(...args) &#123;</span><br><span class="line">  console.log(args instanceof Array)</span><br><span class="line"></span><br><span class="line">  let total = 0</span><br><span class="line">  args.forEach(item =&gt; &#123;</span><br><span class="line">    total += item</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 2, 3, 4)</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展运算符(在调用函数的时候,使用的…的运算符来扩展数组,…运算符称为扩展运算符)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ----------------------扩展运算符--------------</span><br><span class="line">function add(...values) &#123;</span><br><span class="line">  let total = 0</span><br><span class="line">  values.forEach(item =&gt; &#123;</span><br><span class="line">    total += item</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  console.log(total)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [1, 2, 3]</span><br><span class="line">add(...arr)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="箭头函数-是ES6中新增的函数形式-【今后我们会每天写箭头函数的】"><a href="#箭头函数-是ES6中新增的函数形式-【今后我们会每天写箭头函数的】" class="headerlink" title="箭头函数(是ES6中新增的函数形式)【今后我们会每天写箭头函数的】"></a>箭头函数(是ES6中新增的函数形式)【今后我们会每天写箭头函数的】</h3><ol>
<li>如何把 function 改成 箭头函数呢：  先把 function 删掉，然后，在 ()  和 { } 之间，添加一个 <code>=&gt;</code> 就好了</li>
<li>箭头函数的特性： 箭头函数内部的 this, 永远和 箭头函数外部的 this 保持一致；</li>
<li>箭头函数,本质上就是一个匿名函数 (不能直接调用)</li>
<li>最标准的箭头函数格式是      ( 参数列表 ) =&gt; { 函数体 }</li>
<li>变体1： 如果 箭头函数左侧的 形参列表中，只有一个 形参，那么，( ) 可以省略   ( x ) =&gt; { console.log(x) }     可以改造成     x =&gt; { console.log(x) }</li>
<li>变体2：如果 箭头函数右侧的 函数体中，只有一行代码，那么， { } 可以省略    (x, y) =&gt; {console.log(x + y)}  可以改造成    (x, y) =&gt; console.log(x + y)</li>
<li>变体3：如果箭头函数 左侧 只有一个形参，右侧只有一行代码，那么， 左侧的 () 和 右侧的 {} 都可以省略  ( x ) =&gt; { console.log(x) }   可以改造成     x =&gt; console.log(x)</li>
<li>注意： 如果我们省略了 右侧的 { }， 那么，默认就会把 右侧函数体中的代码执行结果，返回出去     (x, y) =&gt; { return  x + y }   可以简写成    (x, y) =&gt; x + y<h3 id="对象中定义方法和属性的便捷方式"><a href="#对象中定义方法和属性的便捷方式" class="headerlink" title="对象中定义方法和属性的便捷方式"></a>对象中定义方法和属性的便捷方式</h3></li>
</ol>
<h2 id="在Node中使用fs模块进行文件操作"><a href="#在Node中使用fs模块进行文件操作" class="headerlink" title="在Node中使用fs模块进行文件操作"></a>在Node中使用fs模块进行文件操作</h2><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  // 1. 使用require 来导入需要的模块</span><br><span class="line">  const fs = require(&apos;fs&apos;)</span><br><span class="line">  // 参数一: 要读取文件的路径</span><br><span class="line">  // 参数二: 可选参数,表示字符编码, 默认为空null</span><br><span class="line">  // 参数三: callback回调函数</span><br><span class="line">  // fs.readFile(&apos;./files/1.txt&apos;, function (err,buf)&#123;</span><br><span class="line">  // console.log(err)//null</span><br><span class="line">  // console.log(buf.toString())//Buffer是一种类型,表示二进制的意思</span><br><span class="line">  // 如果读取文件没有出错,则err默认为null,buf是读取到的二进制</span><br><span class="line">  // 可以调用buffer.toString转换为正常的字符串</span><br><span class="line"></span><br><span class="line">  // Buffer 实例和字符串拼接,得到的结果,是一个字符串</span><br><span class="line">  // console.log(buf + &apos;&apos;)</span><br><span class="line">  // &#125;)</span><br><span class="line"></span><br><span class="line">  // fs.readFile(&apos;./files/1.txt&apos;,(err,buf) =&gt; &#123;</span><br><span class="line">  // Error 实例对象中,有个message属性,表示错误信息</span><br><span class="line">  // if(err)return console.log(err.message)</span><br><span class="line">  // console.log(buf.toString())</span><br><span class="line">  // &#125;)</span><br><span class="line">  // 第二个参数可以用&apos;utf-8&apos;的编码格式,这样buf就不用转换为字符串</span><br><span class="line">  fs.readFile(&apos;./files/1.txt&apos;,&apos;utf-8&apos;,(err,dataStr) =&gt; &#123;</span><br><span class="line">    // Error 实例对象中,有个message属性,表示错误信息</span><br><span class="line">    if(err)return console.log(err.message)</span><br><span class="line">    console.log(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h3><ul>
<li>参数一: 文件路径</li>
<li>参数二: 要写入的数据</li>
<li>参数三: 可选的编码格式, 默认utf-8</li>
<li>参数四: 文件写入后的回调函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  const fs = require(&apos;fs&apos;)</span><br><span class="line">  // 写入文件到指定文件中去(会覆盖原来的内容)</span><br><span class="line">  fs.write(&apos;文件路径&apos;,&apos;内容&apos;,(err) =&gt; &#123;</span><br><span class="line">     // 内容的改变会覆盖上一次的上传</span><br><span class="line">    if(err) return console.log(&apos;写入失败了:&apos; + err.message)</span><br><span class="line">    console.log(&apos;写入成功了!&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">  // fs.copyFile 也可以,但它只支持8.5.0以上的版本</span><br><span class="line">  fs.copyFile(&apos;./files/1.txt&apos;&apos;./files/1-copy.txt&apos;(err) =&gt; &#123;</span><br><span class="line">    if(err) return console.log(&apos;写入文件失败:&apos; + err.message)</span><br><span class="line">    console.log(&apos;恭喜,写入成功&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文件追加"><a href="#文件追加" class="headerlink" title="文件追加"></a>文件追加</h3><ul>
<li>fs.appendFile(file,data[,option],callback)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 1. 导入 fs 文件系统模块</span><br><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line">// 参数一: 要追加的文件的路径</span><br><span class="line">// 参数二: 要追加的数据内容</span><br><span class="line">// 第三个参数:追加时候的编码格式 默认为utf-8</span><br><span class="line">// 参数三: 追加完毕之后的回调函数</span><br><span class="line">fs.appendFile(&apos;./files/2.txt&apos;,&apos;\n降龙十八掌&apos;,(err) =&gt; &#123;</span><br><span class="line">    if(err) return console.log(&apos;写入文件失败:&apos; + err.message)</span><br><span class="line">    console.log(&apos;恭喜,写入成功&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="fs模块中路径操作问题【难点】"><a href="#fs模块中路径操作问题【难点】" class="headerlink" title="fs模块中路径操作问题【难点】"></a>fs模块中路径操作问题【难点】</h3><ul>
<li>在Node中,使用fs模块来操作文件的时候,如果我们给定的路径是一个以’./‘开头的相对路径,找文件指的是Node命令所在的目录来查找 ,所以<strong>最好使用绝对路径(拼接成绝对路径 __dirname + ‘文件名’)</strong></li>
</ul>
<ol>
<li>__dirname 表示当前文件所在的目录</li>
<li>__filename 表示当前文件的完整路径</li>
</ol>
<ul>
<li>const path = require(‘path’) const abspath = path.join(__dirname,’文件名’)来解决/的问题</li>
<li><strong>注意: 今后在使用fs模块中任意方法时只要涉及路径的操作都是用_dirname做拼接</strong></li>
</ul>
<h3 id="读取文件信息-fs-stat"><a href="#读取文件信息-fs-stat" class="headerlink" title="读取文件信息   fs.stat"></a>读取文件信息   fs.stat</h3><ul>
<li>fs.stat(path,callback)<h3 id="读取指定目录中所有文件的名称-fs-readdir"><a href="#读取指定目录中所有文件的名称-fs-readdir" class="headerlink" title="读取指定目录中所有文件的名称   fs.readdir"></a>读取指定目录中所有文件的名称   fs.readdir</h3></li>
<li>fs.readir(path[,option],callback)</li>
</ul>
<h2 id="在ES6中用path来进行路径操作"><a href="#在ES6中用path来进行路径操作" class="headerlink" title="在ES6中用path来进行路径操作"></a>在ES6中用path来进行路径操作</h2><ol>
<li>path.join([…paths])</li>
</ol>
<ul>
<li>path.join 来解决路径分隔符的问题</li>
<li>今后只要涉及到路径的拼接，推荐大家使用 path.join 方法</li>
</ul>
<ol start="2">
<li>path.sep</li>
<li>path.basename(path[, ext])</li>
<li>path.dirname(path)</li>
<li>path.extname(path)<h2 id="Javascript-是单线程的一门语言"><a href="#Javascript-是单线程的一门语言" class="headerlink" title="Javascript 是单线程的一门语言"></a>Javascript 是单线程的一门语言</h2></li>
<li>什么是单线程：用户无法主动开启子线程，对于JS的运行来说，永远是主线程在执行关键代码；</li>
<li>什么是多线程：用户可以主动开启子线程；    Thread  td = new Thread()</li>
<li>在Node中，操作文件和网络都是比较耗时的操作；</li>
</ol>
<h2 id="Node中为什么大量使用异步方法"><a href="#Node中为什么大量使用异步方法" class="headerlink" title="Node中为什么大量使用异步方法"></a>Node中为什么大量使用异步方法</h2><ol>
<li>为什么要使用 异步方法呢： 因为 异步方法，不会阻塞CPU去执行其它任务；</li>
<li>为什么在Node中不推荐使用同步呢： 因为 同步，需要一个一个执行，耗时的操作会阻碍CPU执行后续任务，因此，效率慢；</li>
</ol>
<h2 id="CommonJS-模块规范和模块的使用"><a href="#CommonJS-模块规范和模块的使用" class="headerlink" title="CommonJS 模块规范和模块的使用"></a>CommonJS 模块规范和模块的使用</h2><p>Node.js 实现了 CommonJS 模块化规范；</p>
<ol>
<li>什么是 CommonJS 规范？<ul>
<li>CommonJS 是<strong>为了实现 Javascript 的模块化</strong>，而制定的一套规范；</li>
</ul>
</li>
<li>为什么 Javascript 需要模块化？(require,exports,module)<ul>
<li>所谓的模块化,就是在一个js文件中,能够引入其他的js文件</li>
<li>浏览器中的Javascript有没有实现模块化？（在一个JS文件中，能不能引用另外JS文件中的方法）</li>
<li>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</li>
</ul>
</li>
<li>如何实现 Javascript 的模块化？<ul>
<li>为了统一大家编写模块时候的规则，方便各模块之间的依赖和调用，于是 CommonJS 规范就应运而生了。</li>
</ul>
</li>
<li>那么，CommonJS 模块化规范，到底是个什么东西？？<ul>
<li>定义了什么是模块</li>
</ul>
<ul>
<li>在NodeJs中,可以认为一个js文件就是一个模块,一个模块可以是一个js文件,也可以是由多个js文件组成的</li>
</ul>
<ul>
<li>一个JS模块中，如何引入其它的JS模块</li>
</ul>
<ul>
<li>用require引入: require(‘路径’)</li>
</ul>
<ul>
<li>一个JS模块中，如何向外暴露一些成员，供其它模块调用；</li>
</ul>
<ul>
<li><code>exports.xxx = xxxx</code></li>
<li>使用module对象去访问当前模块, <code>module.exports.xxx=xxx</code></li>
</ul>
<ul>
<li>如果没有类似于 CommonJS 的规范，行不行？</li>
<li>只有大家遵守同样的规范，才能够协作开发，方便别人，同时也方便自己；</li>
</ul>
</li>
</ol>
<h2 id="全局作用域和模块作用域"><a href="#全局作用域和模块作用域" class="headerlink" title="全局作用域和模块作用域"></a>全局作用域和模块作用域</h2><ol>
<li>每个JS文件，就是一个独立的模块，在这个JS文件中，所定义的任何方法、属性、变量、常量、对象，默认都属于模块作用域，并不会属于 全局作用域；</li>
<li>如果在某个模块内部，想为 全局的 global 作用域挂载一些属性，需要显示的调用<code>global.***</code>来挂载；<h3 id="global（全局作用域）"><a href="#global（全局作用域）" class="headerlink" title="global（全局作用域）"></a>global（全局作用域）</h3></li>
</ol>
<ul>
<li>使用global这个全局对象,会造成全局变量的污染(推荐使用CommonJS规范中定义模块化机制来向外暴露成员)<h3 id="require（模块引用）"><a href="#require（模块引用）" class="headerlink" title="require（模块引用）"></a>require（模块引用）</h3>每一个实现了 CommonJS 规范的模块，必须定义一个 require() 函数，使用这个 require 函数，就能够 很方便的导入其它 模块中的成员，供自己使用；<h3 id="exports（模块定义）"><a href="#exports（模块定义）" class="headerlink" title="exports（模块定义）"></a>exports（模块定义）</h3>每一个模块中，如果想要把自己的一些私有成员，暴露给别人使用，那么，必须实现一个 exports 对象，这个对象，将来，如果你想把自己的成员，暴露给别人使用，只需要把自己的成员，挂载到 exports 上就行了(exports默认是空对象)<h3 id="module（模块标识）"><a href="#module（模块标识）" class="headerlink" title="module（模块标识）"></a>module（模块标识）</h3>这个 module 也是Common JS 规定的，它表示一个具体的模块，也是一个对象；</li>
</ul>
<h2 id="module-exports-和-exports-的关系"><a href="#module-exports-和-exports-的关系" class="headerlink" title="module.exports 和 exports 的关系"></a>module.exports 和 exports 的关系</h2><ul>
<li>在一个模块中,默认情况下module.exports和exports是指向同一个空对象的</li>
<li>在一个模块中,在向外暴露成员的时候,永远以module.exports指向的对象为准</li>
</ul>
<h2 id="Node-中的-Javascript-由几部分组成"><a href="#Node-中的-Javascript-由几部分组成" class="headerlink" title="Node 中的 Javascript 由几部分组成"></a>Node 中的 Javascript 由几部分组成</h2><ol>
<li>ECMAScript 核心</li>
<li>全局成员</li>
<li>模块系统成员<ul>
<li>模块系统成员，根据一些区别，又可以分为三大类： 核心模块、第三方模块、用户自定义模块</li>
</ul>
</li>
</ol>
<h2 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h2><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><ol>
<li>什么是核心模块：由Node官方提供的好用的模块，叫做核心模块；只要大家在计算机中，安装了Node这个应用程序，那么，我们的计算机中就已经安装了所有的 核心模块；</li>
<li>如何使用核心模块：<code>require(&#39;核心模块标识符&#39;)</code><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3></li>
<li>什么是第三方模块：一些非官方提供的模块，叫做第三方模块；注意，第三方模块，并不在我们的计算机上，如果大家需要使用某些第三方模块，必须去一个叫做 <code>NPM</code> 的网站上搜索并下载才能使用；</li>
<li>如何使用第三方模块：<ul>
<li>先从 npm 官网上下载指定的第三方模块</li>
<li>使用 <code>require(&#39;第三方模块的名称标识符&#39;)</code>来导入这个模块</li>
<li>根据 第三方模块的 官方文档，尝试使用<h3 id="用户自定义模块"><a href="#用户自定义模块" class="headerlink" title="用户自定义模块"></a>用户自定义模块</h3></li>
</ul>
</li>
<li>什么是用户模块：程序员自己写的JS文件，就叫做 用户自定义模块；</li>
<li>如何使用用户模块：<code>require(&#39;路径标识符&#39;)</code></li>
</ol>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="什么是包"><a href="#什么是包" class="headerlink" title="什么是包"></a>什么是包</h3><ol>
<li>英文名叫做 <code>Packages</code>，包是在模块基础上更深一步的抽象，目的是：方便分发推广基于 CommonJS 规范实现的 应用程序 或 类库；</li>
<li>包可以看作是 模块、代码 和 其它资源 组合起来形成的 独立作用域；</li>
</ol>
<h3 id="定义一个包"><a href="#定义一个包" class="headerlink" title="定义一个包"></a>定义一个包</h3><ol>
<li>首先包应该是一个独立的文件夹(名字应该是英文)</li>
<li>包的文件夹里面应该有一个package.json文件</li>
<li>package.json是一个json文件,在文件里编写的代码必须符合json规范(编写一个对象,对象有三个属性: name,version, main)</li>
<li>自定义的包目录(图片)</li>
</ol>
<h3 id="规范的包结构"><a href="#规范的包结构" class="headerlink" title="规范的包结构"></a>规范的包结构</h3><ol>
<li><strong>包都要以一个单独的目录而存在</strong>；</li>
<li><strong><code>package.json</code> 必须在包的顶层目录下</strong>；</li>
<li><strong><code>package.json</code> 文件必须符合 JSON 格式，并且必须包含如下三个属性：<code>name</code>, <code>version</code>, <code>main</code></strong><ul>
<li>name:  包的名字(名字不能为中文)</li>
<li>version: 包的版本号</li>
<li>main: 表示包的入口文件</li>
</ul>
</li>
<li>二进制文件应该在<strong>bin目录</strong>下;</li>
<li>javaScript代码应该在<strong>lib目录</strong>下;</li>
<li>文档应该在<strong>doc目录</strong>下;</li>
<li>单元测试应该在<strong>test目录</strong>下;</li>
<li>Node.js对包要求并没有那么严格，只要顶层目录下有<code>package.json</code>，并<strong>符合基本规范</strong>即可;<h3 id="包描述文件-package-json"><a href="#包描述文件-package-json" class="headerlink" title="包描述文件 package.json"></a>包描述文件 package.json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name：包的名称，必须是唯一</span><br><span class="line">description：包的简要说明</span><br><span class="line">version：符合语义化版本识别规范的版本字符串</span><br><span class="line">keywords：关键字数据，通常用于搜索</span><br><span class="line">maintainers：维护者数组，每个元素要包含name、email、web可选字段</span><br><span class="line">contributors：贡献者数组，格式与maintainers相同。包的坐着应该是贡献者数据的第一个元素</span><br><span class="line">bugs：提交bug的地址，可以是网址或者电子邮件地址</span><br><span class="line">licenses：许可证数组，每个元素要包含type和url字段</span><br><span class="line">repositories：仓库托管地址数组，每个元素要包含type、url和path字段</span><br><span class="line">dependencies：包的依赖，一个关联数组，由包名称和版本号组成。</span><br><span class="line">devDependencies：开发依赖项，表示一个包在开发期间用到的依赖项</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="npm-的两层含义"><a href="#npm-的两层含义" class="headerlink" title="npm 的两层含义"></a>npm 的两层含义</h3><ol>
<li>NPM 是一个 第三方模块的托管网站，指的就是<code>https://www.npmjs.com/</code>；</li>
<li>NPM 是Node的包管理工具（全名叫做  Node package manager），在我们安装Node时候，就已经顺便也安装了 NPM 这个管理工具；<h3 id="安装和卸载全局包"><a href="#安装和卸载全局包" class="headerlink" title="安装和卸载全局包"></a>安装和卸载全局包</h3></li>
<li>什么是全局的包：通过  <code>npm install  包名  -g</code> 方式安装的包，都安装到了全局；一般全局的安装目录是<code>C:\Users\自己的用户文件夹\AppData\Roaming\npm</code></li>
<li>带大家演示如何安装一个全局的包：<code>npm install i5ting_toc -g</code>， 注意：这里的<code>-g</code>表示全局安装包的意思；</li>
<li>注意：一般，只有一些工具，才有全局安装的必要性；</li>
<li>如果要全局卸载某个包，比如要卸载 <code>i5ting_toc</code>了，直接运行<code>npm uninstall i5ting_toc -g</code>就可以全局卸载包了！<h3 id="安装和卸载本地包"><a href="#安装和卸载本地包" class="headerlink" title="安装和卸载本地包"></a>安装和卸载本地包</h3></li>
<li>什么是本地的包：跟着项目安装的包，叫做本地包；</li>
<li>如果拿到一个空项目，必须先初始化一个<code>package.json</code>的配置文件，<code>npm init</code>或者<code>npm init -y</code>(方便些)</li>
<li>运行<code>npm i 包名@版本号 --save</code>去安装指定的包，本地安装的包，都安装到了<code>node_modules</code>的目录下</li>
<li>如果大家用的是npm 5.x的版本，可以不指定<code>--save</code>命令，如果用的是 npm 3.x 的版本，则需要手动指定 <code>--save</code>, 同时，<code>--save</code>有缩写形式，是：<code>-S</code></li>
<li><code>package-lock.json</code>文件中记录了曾经装过的包的下载地址，方便下次直接下载包；</li>
<li>卸载本地包: <code>npm uninstall 包名 --save</code><h3 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h3></li>
<li><code>--save-dev</code>它的缩写是<code>-D</code></li>
<li>注意：<code>dependencies</code>节点，表示项目上线部署时候需要的依赖项；<code>devDependencies</code>节点，表示项目在开发阶段需要的依赖项，但是当项目要部署上线了，<code>devDependencies</code>节点中的包，就不再需要了！</li>
<li>注意：当使用<code>npm i</code>快速装包的时候，npm会检查<code>package.json</code>文件中，所有的依赖项，然后都为我们安装到项目中</li>
<li><code>--production</code> 表示只安装 <code>dependencies</code> 节点下，记录的包，不安装<code>devDependencies</code>节点下的包；当项目要上线了，才会使用<code>--production</code>命令<h3 id="解决-npm-下载慢问题"><a href="#解决-npm-下载慢问题" class="headerlink" title="解决 npm 下载慢问题"></a>解决 npm 下载慢问题</h3></li>
<li>默认，NPM在下载包的时候，连接的是国外的服务器，所以，有时候如果网速不是特别好，可能下载不下来包；此时，大家可以安装一个工具，叫做<code>nrm</code>，里面记录了好多下载NPM包的服务器地址，可以让我们方便的切换下载包时候请求的服务器；</li>
<li>运行<code>npm i nrm -g</code>（注意：只要是工具，一般都是全局 -g 安装）</li>
<li>当装完 nrm 之后，可以运行<code>nrm ls</code> 查看所有可用的服务器列表</li>
<li>可使用<code>nrm use 服务器名称</code>来切换下载包时候的服务器地址</li>
</ol>
<h2 id="构建web应用"><a href="#构建web应用" class="headerlink" title="构建web应用"></a>构建web应用</h2><p>Apache 是一个PHP的服务器，当我们把做好的网站，丢到 WWW 目录下，就能够使用 IP地址 + 端口号 访问我们的网站了；</p>
<ul>
<li>IP地址的作用，是为了表示当前网络中这台计算机唯一身份的；</li>
<li>端口号：端口号和应用程序有关联，每一个应用程序，只能独占一个端口号，不能说多个应用程序公用一个端口；<br>疑问：Node中，有没有类似于 Apache 这样的服务器软件，来提供对应的网站服务呢？注意：Node中，并没有现成的 类似于 Apache 的服务器软件，如果我们想通过Node，来对外托管一个网站的话，需要自己手写一个 类似于 Apache 的服务器；<h3 id="BS-交互模型"><a href="#BS-交互模型" class="headerlink" title="BS 交互模型"></a>BS 交互模型</h3></li>
</ul>
<ol>
<li>HTTP 协议是基于 <code>请求 - 处理 - 响应</code> 通信模型的<h3 id="实现静态资源服务器"><a href="#实现静态资源服务器" class="headerlink" title="实现静态资源服务器"></a>实现静态资源服务器</h3></li>
<li>后端路由的本质</li>
</ol>
<ul>
<li>重点理解URL(统一资源定位符)的本质<h3 id="在-Node-中使用模板引擎"><a href="#在-Node-中使用模板引擎" class="headerlink" title="在 Node 中使用模板引擎"></a>在 Node 中使用模板引擎</h3><h2 id="使用-http-核心模块-构建自己的-web-server（web服务器）"><a href="#使用-http-核心模块-构建自己的-web-server（web服务器）" class="headerlink" title="使用 http 核心模块 - 构建自己的 web server（web服务器）"></a>使用 <code>http</code> 核心模块 - 构建自己的 web server（web服务器）</h2><h3 id="理解-BS-交互模型"><a href="#理解-BS-交互模型" class="headerlink" title="理解 BS 交互模型"></a>理解 BS 交互模型</h3>B/S：表示  Browser / Server        C/S     Client / Server</li>
</ul>
<ol>
<li>什么是服务器：在网络节点中，专门对外提供资源服务的一台电脑；</li>
<li>什么是客户端：在网络节点中，专门用来消耗或呈现服务器中返回的数据的电脑；</li>
<li>什么是静态资源：像 .js ,  .css, .jpg,  .html   ；所谓的静态资源，就是无需数据交互，服务器直接把资源读取，并响应给客户端就完事儿；</li>
<li>什么是动态资源：当一些资源，服务器上并没有现成的，需要现在服务器端，做一层处理，最后把处理的结果返回给客户端，这样的资源，叫做动态资源；</li>
<li>HTTP 协议的通信模型：<code>请求 - 处理 - 响应</code>的过程；<h3 id="创建基本http服务器"><a href="#创建基本http服务器" class="headerlink" title="创建基本http服务器"></a>创建基本http服务器</h3></li>
</ol>
<ul>
<li>1.先导入Node中提供分核心模块 http : const http = require(‘http’)</li>
<li><ol start="2">
<li>创建服务器 : const server = http.createServer()</li>
</ol>
</li>
<li><ol start="3">
<li>为这个server服务器,通过on方法,绑定一个事件: server.on(‘request’,function(){<br>console.log(‘ok)<br>})</li>
</ol>
</li>
<li><ol start="4">
<li>启动服务器: server.listen(3000,function(){<br>console.log(‘通知大家,服务器已经启动’)<br>})<h3 id="解决返回内容的编码格式"><a href="#解决返回内容的编码格式" class="headerlink" title="解决返回内容的编码格式"></a>解决返回内容的编码格式</h3></li>
</ol>
</li>
<li>200 是状态码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.writeHeader(200,&#123;</span><br><span class="line">  &quot;Content-Type&quot;:&apos;text/html;chartset=utf-8&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="实现静态资源服务器-1"><a href="#实现静态资源服务器-1" class="headerlink" title="实现静态资源服务器"></a>实现静态资源服务器</h3><ol>
<li>后端路由的本质</li>
</ol>
<ul>
<li>重点理解URL（统一资源定位符）的本质</li>
<li>注意: res.end()方法只接受字符串或Buffer二进制,在网络传输中内容都是以二进制进行传输的<h3 id="结合模板引擎实现动态资源服务器"><a href="#结合模板引擎实现动态资源服务器" class="headerlink" title="结合模板引擎实现动态资源服务器"></a>结合模板引擎实现动态资源服务器</h3></li>
</ul>
<h2 id="静态资源请求路径问题"><a href="#静态资源请求路径问题" class="headerlink" title="静态资源请求路径问题"></a>静态资源请求路径问题</h2><ol>
<li>在浏览器的眼中，只要是地址栏中的地址，浏览器永远把 最后一个 <code>/</code> 后面的符号，认为是文件名</li>
<li>对于服务器来说，客户端请求的 URL 资源路径只是一个 <strong>标识符</strong> 而已，URL 不一定非要对应实际的物理磁盘路径！</li>
<li>一定要区分html中书写的路径标识符 <code>../</code>    <code>./</code>  和 <code>/</code> <strong>在浏览器中</strong>代表含义！</li>
</ol>
<ul>
<li><code>/</code>   表示，直接从端口号后面，开始资源请求</li>
<li><code>./</code>  表示，在发起资源请求之前，浏览器需要先 把 URL 地址 ，和 资源路径做一层拼接</li>
<li><p><code>../</code> 表示，在发起资源请求之前，浏览器需要先 把 URL 地址 ，和 资源路径做一层拼接</p>
<h2 id="使用-nodemon-工具来自动重启web服务器"><a href="#使用-nodemon-工具来自动重启web服务器" class="headerlink" title="使用 nodemon 工具来自动重启web服务器"></a>使用 <code>nodemon</code> 工具来自动重启web服务器</h2></li>
<li>这个工具的作用：能够实时监听 web 服务器中，代码的改变，只要代码被修改并保存了，则 nodemon 工具，会自动重新启动 web 服务器；</li>
<li>运行 <code>npm i nodemon -g</code> 就能够在全局环境中，安装这个工具了</li>
<li>当安装完毕 <code>nodemon</code> 之后，就可以 使用 <code>nodemon 要执行的js文件路径</code> 来运行JS文件了</li>
<li>今后在开发Web项目的时候，推荐使用 nodemon 来执行 web 服务器</li>
</ul>
<h2 id="Node-中的-Web-快速开发框架-Express"><a href="#Node-中的-Web-快速开发框架-Express" class="headerlink" title="Node 中的 Web 快速开发框架 - Express"></a>Node 中的 Web 快速开发框架 - Express</h2><p>定义什么是Express：</p>
<ol>
<li>基于 Node.js 后端Javascript平台之上，开发出来的一套Web开发框架； </li>
<li>Express中，基于 原生Node的特性，做了进一步的封装，提供了一些更加好用的方法，来提高Web开发的体验；</li>
<li>Express中，并没有覆盖或者删除原生的http模块方法；<h3 id="express-框架的安装和基本使用"><a href="#express-框架的安装和基本使用" class="headerlink" title="express 框架的安装和基本使用"></a>express 框架的安装和基本使用</h3></li>
<li>直接运行 <code>npm install express --save</code> 就可以安装Express框架了<h3 id="使用-express-快速托管静态资源"><a href="#使用-express-快速托管静态资源" class="headerlink" title="使用 express 快速托管静态资源"></a>使用 express 快速托管静态资源</h3></li>
<li>如果我们网站中，有很多静态资源需要被外界访问，此时，使用 res.sendFile 就有点力不从心了，这时候，express 框架，为我们提供了一个 内置的（中间件）  <code>express.static(&#39;静态资源目录&#39;)</code>  ， 来快速托管指定目录下的所有静态资源文件；</li>
<li>用法： <code>app.use(express.static(&#39;public&#39;));</code></li>
</ol>
<ul>
<li>其中， <code>express.static</code> 是一个express的内置中间件；</li>
<li><code>app.use()</code>方法，是专门用来注册 中间件；</li>
</ul>
<ol start="3">
<li><p>当使用 第二步中的方法，把指定目录托管为静态资源目录之后，那么，这一层被托管的目录，不应该出现在 资源访问的 URL地址中；</p>
</li>
<li><p>在一个Web项目中，我们可以多次调用<code>app.use(express.static())</code></p>
</li>
<li><p>在多次调用 express.static 的时候，如果文件名称有重复的，则以先注册的中间件为主！</p>
</li>
<li><p>如果项目要部署了，推荐大家配置一个叫做<code>compression</code>的中间件，它能够开启服务器的GZip压缩功能；</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var compression = require(&apos;compression&apos;) app.use(compression())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="为-express-框架配置模板引擎渲染动态页面"><a href="#为-express-框架配置模板引擎渲染动态页面" class="headerlink" title="为 express 框架配置模板引擎渲染动态页面"></a>为 express 框架配置模板引擎渲染动态页面</h3><ol>
<li>安装 ejs 模板引擎<code>npm i ejs -S</code></li>
<li>使用 app.set() 配置默认的模板引擎 <code>app.set(&#39;view engine&#39;, &#39;ejs&#39;)</code></li>
<li>使用 app.set() 配置默认模板页面的存放路径 <code>app.set(&#39;views&#39;, &#39;./views&#39;)</code></li>
<li>使用 res.render() 来渲染模板页面<code>res.render(&#39;index.ejs&#39;, { 要渲染的数据对象 })</code>，注意，模板页面的 后缀名，可以省略不写！</li>
<li>使用res.send()来解决中文乱码问题<h3 id="使用-express-框架中提供的路由来分发请求"><a href="#使用-express-框架中提供的路由来分发请求" class="headerlink" title="使用 express 框架中提供的路由来分发请求"></a>使用 express 框架中提供的路由来分发请求</h3></li>
<li>什么叫做路由：前端请求的URL地址，都要对应一个后端的处理函数，那么 这种URL地址到 处理函数之间的对应关系，就叫做后端路由；</li>
<li>在Express中，路由主要负责 分发请求处理的；</li>
<li><p>在Express中，如何 定义并使用路由呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1. 封装单独的 router.js 路由模块文件</span><br><span class="line">const express = require(&apos;express&apos;)</span><br><span class="line">// 创建路由对象</span><br><span class="line">const router = express.Router()</span><br><span class="line"></span><br><span class="line">router.get(&apos;/&apos;, (req, res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(&apos;/movie&apos;, (req, res)=&gt;&#123;&#125;)</span><br><span class="line">router.get(&apos;/about&apos;, (req, res)=&gt;&#123;&#125;)</span><br><span class="line"></span><br><span class="line">// 导出路由对象</span><br><span class="line">module.exports = router</span><br></pre></td></tr></table></figure>
</li>
<li><p>express创建的 app 服务器，如何使用 路由模块呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 导入自己的路由模块</span><br><span class="line">const router = require(&apos;./router.js&apos;)</span><br><span class="line">// 使用 app.use() 来注册路由</span><br><span class="line">app.use(router)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Express-框架里-中间件的概念"><a href="#Express-框架里-中间件的概念" class="headerlink" title="Express 框架里 中间件的概念"></a>Express 框架里 中间件的概念</h2><ol>
<li>什么是中间件</li>
</ol>
<ul>
<li>中间件是一个函数</li>
<li>中间价这个函数是一个路由的处理函数</li>
<li>中间件这个函数,不但是一个路由处理函数,而且在参数列表中,还有一个很重要的形参,叫做next</li>
<li>这个next是一个函数, 因此,我们在中间件中,调用这个next()函数</li>
<li>中间件的表现形式: 只要这个函数的形参列表中,有一个next函数,它就是中间件</li>
</ul>
<ol start="2">
<li>中间件的作用是</li>
</ol>
<ul>
<li>中间件表示每一个处理环节,这些处理环节,只负责单独的处理,每当上一个中间件处理完毕后,必须把处理的原材料交给下一个中间件来继续处理</li>
<li>中间件之间,共享的是 req和res这两个对象</li>
</ul>
<ol start="3">
<li>如何注册中间件</li>
</ol>
<ul>
<li>app.use(中间件的函数)</li>
</ul>
<ol start="4">
<li>中间件里<code>next</code>函数的作用</li>
</ol>
<ul>
<li>从上一个中间件处理函数中,进入下一个中间件处理函数<h3 id="自己模拟一个解析表单数据的中间件"><a href="#自己模拟一个解析表单数据的中间件" class="headerlink" title="自己模拟一个解析表单数据的中间件"></a>自己模拟一个解析表单数据的中间件</h3></li>
</ul>
<ol>
<li>自己模拟中间件的时候，需要使用 <code>req.on(&#39;data&#39;, (chunk)=&gt;{})</code>和<code>req.on(&#39;end&#39;, ()=&gt;{})</code> 来获取表单，并使用 <code>querystring</code>模块的<code>parse</code>方法来解析成对象；</li>
<li>我们在开发中，推荐大家直接使用第三方的<code>body-parser</code>中间件来解析表单；<h3 id="Express-框架中对中间件的5种分类"><a href="#Express-框架中对中间件的5种分类" class="headerlink" title="Express 框架中对中间件的5种分类"></a>Express 框架中对中间件的5种分类</h3></li>
<li>应用级别中间件：挂载到 app 对象身上的 中间件（函数 ）</li>
<li>路由级中间件:  挂载到 router 对象上的中间件</li>
<li>错误处理中间件：参数列表中要有四个形参，从前到后分别是 <code>err</code>, <code>req</code>, <code>res</code>, <code>next</code></li>
<li>内置中间件:  Express 中唯一的内置中间件  <code>express.static(root, [options])</code></li>
<li>第三方中间件： 通过 <code>npm</code>安装的中间件，叫做 第三方中间件！</li>
</ol>
<h2 id="Express-中进行数据库操作"><a href="#Express-中进行数据库操作" class="headerlink" title="Express 中进行数据库操作"></a>Express 中进行数据库操作</h2><ol>
<li>用的数据库是MySql</li>
<li>大家是直接安装的MySql</li>
<li>安装了一个叫做 Navicat 的软件，来方便我们操作数据库<h3 id="配置-MySql-数据库环境"><a href="#配置-MySql-数据库环境" class="headerlink" title="配置 MySql 数据库环境"></a>配置 MySql 数据库环境</h3><h3 id="mysql-第三方模块的介绍和基本配置"><a href="#mysql-第三方模块的介绍和基本配置" class="headerlink" title="mysql 第三方模块的介绍和基本配置"></a>mysql 第三方模块的介绍和基本配置</h3><h3 id="使用-mysql-第三方模块实现-CRUD"><a href="#使用-mysql-第三方模块实现-CRUD" class="headerlink" title="使用 mysql 第三方模块实现 CRUD"></a>使用 mysql 第三方模块实现 CRUD</h3></li>
</ol>
<ul>
<li>C： Create</li>
<li>R： Read</li>
<li>U： Update</li>
<li>D： Delete</li>
</ul>
<h2 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h2><ol>
<li>只要使用 <code>require</code> 来加载指定的模块了，那么，必然会执行被加载模块中的代码！<h3 id="优先从缓存中加载"><a href="#优先从缓存中加载" class="headerlink" title="优先从缓存中加载"></a>优先从缓存中加载</h3></li>
<li>Node中，默认会把曾经加载过的模块，缓存到内存中，这样，当下次再使用相同的模块，就直接从缓存中加载就行了，能够提高模块的运行效率；<h3 id="核心模块的加载机制"><a href="#核心模块的加载机制" class="headerlink" title="核心模块的加载机制"></a>核心模块的加载机制</h3></li>
<li>先从缓存中查找，如果有，则直接使用；</li>
<li>如果缓存中没有，则加载本地的核心模块并缓存起来，供下次使用；<h3 id="用户模块的加载机制"><a href="#用户模块的加载机制" class="headerlink" title="用户模块的加载机制"></a>用户模块的加载机制</h3></li>
<li>先从缓存中查找，如果有，则直接使用；</li>
<li>如果缓存中没有，则根据路径标识符，加载本地的用户模块并缓存起来，供下次使用；</li>
<li>用户模块的查找规则：<code>index    -&gt;    index.js    -&gt;   index.json     -&gt;    index.node</code><h3 id="第三方模块的加载机制"><a href="#第三方模块的加载机制" class="headerlink" title="第三方模块的加载机制"></a>第三方模块的加载机制</h3></li>
<li>先从缓存中查找，如果有，则直接使用；</li>
<li>如果缓存中没有，则根据第三方模块的标识符，加载第三方模块并缓存起来，供下次使用；<h3 id="通过学习moment这个第三方模块来了解第三方模块的加载规则"><a href="#通过学习moment这个第三方模块来了解第三方模块的加载规则" class="headerlink" title="通过学习moment这个第三方模块来了解第三方模块的加载规则"></a>通过学习<code>moment</code>这个第三方模块来了解第三方模块的加载规则</h3></li>
<li>会根据包的名称，直接在当前项目的根目录中，去查找一个叫做 <code>node_modules</code> 的文件夹；</li>
<li>如果有，则在 <code>node_modules</code> 中，继续查找，一个叫做 模块引用名称的文件夹；</li>
<li>如果有，则 在 模块对应的文件夹中，查找一个叫做 <code>package.json</code> 的文件；</li>
<li>如果有 <code>package.json</code>， 则查找 其中的 <code>main</code> 属性，并尝试加载 main 指定的文件作为入口；</li>
<li>如果能正常加载 <code>main</code> 属性中指定的文件，则模块/包加载成功！</li>
<li>如果 在 <code>package.json</code> 文件中，没有 main 属性，则会依次尝试加载 包根目录中的 <code>index.js</code>, <code>index.json</code>, <code>index.node</code></li>
<li>如果在 包的根目录中，根本没有 <code>package.json</code> 文件，或者 在 node_modules 目录中没有 index 相关的文件，或者，根本没有对应的包文件夹，或者在项目根目录中根本没有<code>node_modules</code>, 则会向上层目录中，去查找<code>node_modules</code>， 查找规则同上；</li>
<li>如果在上一层目录中还是没有找到对应的模块，则继续向上翻，直到翻到项目所在的磁盘根目录位置；</li>
<li>如果翻到了磁盘的根目录中，还没有找到，此时，会报错！<code>cannot find module ***</code><h2 id="express中获取参数的几种形式"><a href="#express中获取参数的几种形式" class="headerlink" title="express中获取参数的几种形式"></a>express中获取参数的几种形式</h2><h3 id="从URL地址中获取查询参数"><a href="#从URL地址中获取查询参数" class="headerlink" title="从URL地址中获取查询参数"></a>从URL地址中获取查询参数</h3>通过 URL 地址栏中，? 形式传递的参数，可以直接通过 <code>req.query</code> 来获取；<h3 id="从URL地址中获取路径参数"><a href="#从URL地址中获取路径参数" class="headerlink" title="从URL地址中获取路径参数"></a>从URL地址中获取路径参数</h3>直接通过路径标识符来传递参数，<code>/userinfo/10/zs</code>， 可以通过 <code>req.params</code>来获取参数<h3 id="从post表单中获取提交的数据"><a href="#从post表单中获取提交的数据" class="headerlink" title="从post表单中获取提交的数据"></a>从post表单中获取提交的数据</h3></li>
</ol>
<ul>
<li>借助于<code>body-parser</code>来解析表单数据</li>
<li><code>npm i body-parser -S</code></li>
<li><code>const bodyParser = require(&#39;body-parser&#39;)</code></li>
<li><code>app.use(bodyParser.urlencoded({ extended: false }))</code></li>
</ul>
<h2 id="Web-开发模式"><a href="#Web-开发模式" class="headerlink" title="Web 开发模式"></a>Web 开发模式</h2><h3 id="混合模式（传统开发模式）"><a href="#混合模式（传统开发模式）" class="headerlink" title="混合模式（传统开发模式）"></a>混合模式（传统开发模式）</h3><ul>
<li>以后端程序员为主，基本上不需要前端程序员，或者，前端程序员只负责画页面、美化样式、写JS特效，前端程序员不需要进行数据的交互；</li>
<li>这种开发模式，在前几年比较常见；</li>
<li>他们用的最多的是 Jquery + 模板引擎</li>
<li>后端页面 .php   .jsp   .aspx   .cshtml<h3 id="前后端分离（趋势）"><a href="#前后端分离（趋势）" class="headerlink" title="前后端分离（趋势）"></a>前后端分离（趋势）</h3></li>
<li>后端负责操作数据库、给前端暴露接口</li>
<li>前端负责调用接口，渲染页面、前端就可以使用一些流行的前端框架 Vue， React， Angular</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>后端项目运行地址：<a href="http://127.0.0.1:5000" target="_blank" rel="noopener">http://127.0.0.1:5000</a></li>
<li>前端项目运行地址：<a href="http://127.0.0.1:4000" target="_blank" rel="noopener">http://127.0.0.1:4000</a></li>
<li>前后端分离开发模式的注意点：<ul>
<li>跨域问题</li>
<li>如果不考虑 表单的 Post 提交，则 可以使用 JSONP的形式来请求接口</li>
<li>但是，我们的项目中，涉及到了 英雄表单的 提交，表单提交一般都是Post</li>
<li>经过分析，由于JSONP，不支持Post，所以，我们的后端接口，无法设计成JSONP的接口；</li>
</ul>
</li>
</ol>
<h2 id="JSONP-和-CORS-的区别"><a href="#JSONP-和-CORS-的区别" class="headerlink" title="JSONP 和 CORS 的区别"></a>JSONP 和 CORS 的区别</h2><ol>
<li>JSONP的原理：动态创建script标签；<ul>
<li>JSONP发送的不是Ajax请求</li>
<li>不支持 Post 请求；</li>
</ul>
</li>
<li>CORS中文意思是<code>跨域资源共享</code> , 本质，就是使用 XHR 对象，发送Ajax请求，来进行跨域的资源共享；<ul>
<li>CORS 发送的是真正的Ajax请求</li>
<li>CORS 支持Ajax的跨域</li>
<li>如果要启用 CORS 跨域资源共享，关键在于 服务器端，只要 服务器支持CORS跨域资源共享，则 浏览器肯定能够正常访问 这种 CORS 接口；而且，客户端在 发送 Ajax的时候，就像发送普通AJax一样，没有任何代码上的变化；</li>
</ul>
</li>
<li>对于Node来说，如果想要开启 CORS 跨域通信，只需要安装<code>cors</code>的模块即可；<h2 id="HTTP协议的无状态性"><a href="#HTTP协议的无状态性" class="headerlink" title="HTTP协议的无状态性"></a>HTTP协议的无状态性</h2></li>
<li>HTTP协议的通信模型：基于<code>请求 - 处理 - 响应</code>的！</li>
<li>由于这个通信协议的关系，导致了HTTP每个请求之间都是没有关联的，每当一个请求完成之后，服务器就忘记之前谁曾经请求过！</li>
<li>如果纯粹基于HTTP通信模型，是无法完成登录状态保持的！每次请求服务器，服务器都会把这个请求当作新请求来处理！</li>
<li>我们可以通过 cookie 技术，实现状态保持，但是由于cookie是存储在客户端的一门技术，所以安全性几乎没有，因此不要使用cookie存储敏感的数据！</li>
</ol>
<h2 id="cookie介绍"><a href="#cookie介绍" class="headerlink" title="cookie介绍"></a>cookie介绍</h2><h3 id="什么是cookie，作用是什么"><a href="#什么是cookie，作用是什么" class="headerlink" title="什么是cookie，作用是什么"></a>什么是cookie，作用是什么</h3><ul>
<li>由于<strong>Http协议是无状态</strong>的，且传统服务器<strong>只能被动的响应请求</strong>，所以，当服务器获取到请求的时候，并不知道当前请求属于哪个客户端！</li>
<li>服务器为了能够明确区分每个客户端，需要使用一些小技术，来根据不同的请求区分不同的客户端；</li>
<li>只要有请求发生，那么必然对应一个客户端，那么，我们可以在每次客户端发起请求的时候，向服务器自动发送一个标识符，告诉服务器当前是哪个客户端正在请求服务器的数据；</li>
<li>如何提供这个标识符呢？我们可以在请求头(Request Headers)中添加一个标签，叫做<code>cookie</code>，这样，每次发送请求，都会把这个cookie随同其他报文一起发送给服务器，服务器可以根据报文中的cookie，区分不同的客户端浏览器。</li>
<li>如何在客户端请求头中添加标识符？<ul>
<li>在Node中可以在<code>writeHeader</code>的时候，通过<code>Set-Cookie</code>来将cookie标识通过响应报文发送给客户端！</li>
<li>客户端也可以通过一些方式来操作自己的cookie，比如通过<code>jquery.cookie</code>这个插件！</li>
</ul>
</li>
</ul>
<h3 id="cookie的基本使用"><a href="#cookie的基本使用" class="headerlink" title="cookie的基本使用"></a>cookie的基本使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function (req, res) &#123;</span><br><span class="line">    // 解析cookie</span><br><span class="line">    var cookies = &#123;&#125;;</span><br><span class="line">    var cookieStr = req.headers.cookie; // 从请求的headers中获取cookie信息</span><br><span class="line">    cookieStr &amp;&amp; cookieStr.split(&apos;;&apos;).forEach(function (item) &#123;</span><br><span class="line">        var parts = item.split(&apos;=&apos;);</span><br><span class="line">        cookies[parts[0].trim()] = parts[1].trim(); // 将cookie解析出来，保存到对象中</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.writeHeader(200, &#123;</span><br><span class="line">        &apos;Content-Type&apos;: &apos;text/plain; charset=utf-8&apos;,</span><br><span class="line">        &quot;Set-Cookie&quot;: [&apos;issend=ok&apos;, &apos;age=20&apos;]</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if(cookies.issend ===&apos;ok&apos;)&#123;</span><br><span class="line">        res.end(&apos;不要太贪心哦！&apos;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.end(&apos;呐，赏你一朵小红花~~&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(4000, function () &#123;</span><br><span class="line">    console.log(&apos;服务器已启动!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="通过expires设置Cookie的过期时间"><a href="#通过expires设置Cookie的过期时间" class="headerlink" title="通过expires设置Cookie的过期时间"></a>通过<code>expires</code>设置Cookie的过期时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设置 过期时间 为60秒之后</span><br><span class="line">// 注意：在设置过期时间的时候，需要将时间转换为 UTC 格式</span><br><span class="line">var expiresTime = new Date(Date.now() + 1000 * 60).toUTCString();</span><br><span class="line">res.writeHeader(200, &#123;</span><br><span class="line">  &apos;Content-Type&apos;: &apos;text/html; charset=utf-8&apos;,</span><br><span class="line">  &apos;Set-Cookie&apos;: [&apos;isvisit=true;expires=&apos; + expiresTime, &apos;test=OK&apos;]</span><br><span class="line">&#125;);</span><br><span class="line">res.end(&apos;&lt;h3&gt;你好，欢迎光临，送给你一个苹果！&lt;/h3&gt;&apos;);</span><br></pre></td></tr></table></figure>
<p><a href="http://www.wbiao.cn/cartier-watches/knowledge/article-1468.html" target="_blank" rel="noopener">GMT和UTC有什么区别？格林尼治标准时（GMT）与世界时（UTC）是怎么回事</a></p>
<h3 id="cookie可以被伪造，不安全"><a href="#cookie可以被伪造，不安全" class="headerlink" title="cookie可以被伪造，不安全"></a>cookie可以被伪造，不安全</h3><p>使用谷歌插件<code>edit this cookie</code>，就能伪造cookie数据！所以不要使用cookie存储敏感的数据！比如登录状态和登录信息；<br>一些敏感的数据，应该存储都服务器端！</p>
<h3 id="什么是Cookie的应用场景"><a href="#什么是Cookie的应用场景" class="headerlink" title="什么是Cookie的应用场景"></a>什么是Cookie的应用场景</h3><ol>
<li>对安全性要求不高</li>
<li>不需要存储大量的数据</li>
<li>主要应用场景，是用来做 客户端 与 服务器之间的 状态保持技术；</li>
</ol>
<h3 id="使用express-session来保存登录状态"><a href="#使用express-session来保存登录状态" class="headerlink" title="使用express-session来保存登录状态"></a>使用<code>express-session</code>来保存登录状态</h3><h4 id="什么是session"><a href="#什么是session" class="headerlink" title="什么是session"></a>什么是session</h4><p>由于HTTP是无状态的，所以服务器在每次连接中持续保存客户端的私有数据，此时需要结合cookie技术，通过session会话机制，在服务器端保存每个HTTP请求的私有数据；</p>
<h4 id="session原理"><a href="#session原理" class="headerlink" title="session原理"></a>session原理</h4><p>在服务器内存中开辟一块地址空间，专门存放每个客户端私有的数据，每个客户端根据cookie中保存的私有sessionId，可以获取到独属于自己的session数据。</p>
<h4 id="在express中使用session"><a href="#在express中使用session" class="headerlink" title="在express中使用session"></a>在express中使用session</h4><ol>
<li><p>安装session模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-session -S</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入session模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var session = require(&apos;express-session&apos;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在express中使用<code>session</code>中间件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 启用 session 中间件</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: &apos;keyboard cat&apos;, // 相当于是一个加密密钥，值可以是任意字符串</span><br><span class="line">  resave: false, // 强制session保存到session store中</span><br><span class="line">  saveUninitialized: false // 强制没有“初始化”的session保存到storage中</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
</li>
<li><p>将私有数据保存到当前请求的session会话中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 将登录的用户保存到session中</span><br><span class="line">req.session.user = result.dataValues;</span><br><span class="line">// 设置是否登录为true</span><br><span class="line">req.session.islogin = true;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>destroy()</code>方法清空<code>session</code>数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">req.session.destroy(function(err)&#123;</span><br><span class="line">  if(err) throw err;</span><br><span class="line">  console.log(&apos;用户退出成功！&apos;);</span><br><span class="line">  // 实现服务器端的跳转，这个对比于 客户端跳转</span><br><span class="line">  res.redirect(&apos;/&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ol>
<li><a href="http://blog.csdn.net/liangklfang/article/details/50998959" target="_blank" rel="noopener">node.js中express-session配置项详解</a></li>
<li><a href="http://www.cmd5.com/" target="_blank" rel="noopener">MD5在线生成器1</a></li>
<li><a href="http://pmd5.com/" target="_blank" rel="noopener">MD5在线生成器2</a></li>
<li><a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">JavaScript-MD5</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/11/node-js/" data-id="cjkg9cxex0005jsv7jscbobmz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript-summarize" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/05/JavaScript-summarize/" class="article-date">
  <time datetime="2018-07-05T10:51:13.000Z" itemprop="datePublished">2018-07-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/05/JavaScript-summarize/">JavaScript-summarize</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript学习总结【2】、JS基础"><a href="#JavaScript学习总结【2】、JS基础" class="headerlink" title="JavaScript学习总结【2】、JS基础"></a>JavaScript学习总结【2】、JS基础</h1><hr>
<h2 id="JS命名规范"><a href="#JS命名规范" class="headerlink" title="JS命名规范"></a>JS命名规范</h2><p>命名规范是很有必要的，可增强代码的可读性，一眼就能看懂要表达的意思，规范就是符合规则，使代码有利于后期维护，也能很大程度的提高开发效率。一个正常的网站有很多 JS 代码，如果在编写的过程中，不遵循某种规则，那么写到后面自己都看不懂自己写的什么，这是很麻烦的一件事，所以要在平时的练习过程中，养成良好的编写代码的习惯。</p>
<ul>
<li><strong>一般都采用匈牙利命名法或者驼峰命名法。</strong></li>
<li><strong>匈牙利命名法的原则：变量名=属性+类型+对象描述。他的关键是：以一个或多个小写字母作为前缀，前缀之后是一个或多个首字母大写的单词组合，该单词指明变量的用途。</strong></li>
<li><strong>驼峰命名法的原则：第一个单词以小写字母开始，之后每一个单词的首字母大写。例如：myFirstName、myLastName，这样的变量名看上去就像驼峰一样此起彼伏，因此得名。驼峰法的关键是：除第一个单词外，其他单词首字母大小，混合使用大小写字母来构成变量名和函数名，还可以使用下划线来形成逻辑断点，这样更能增强代码的可读性。</strong></li>
</ul>
<h2 id="注释很重要"><a href="#注释很重要" class="headerlink" title="注释很重要"></a>注释很重要</h2><ul>
<li><strong>JS中单行注释用“ // 注释内容” 标识，多行注释使用“  /<em> 注释内容 </em>/  “标识。注释的作用是提高代码的可读性，不仅自己以后用着方便，也有助于别人阅读和理解你所编写的JS代码，注释中的内容不会在网页中显示。</strong>为了方便阅读，注释一般放在需要解释的语句结尾处或者周围。在学习的过程中，我们更要养成书写注释的良好习惯，有利于我们对于代码的理解，或者标记出当时比较模糊的概念，回头再做深入的定向学习，更牢固的掌握该知识点。</li>
</ul>
<h2 id="JS语句和符号"><a href="#JS语句和符号" class="headerlink" title="JS语句和符号"></a>JS语句和符号</h2><ul>
<li><p><strong>JS 语句是发送给浏览器的命令。这些命令的作用是告诉浏览器要做的事情。JS 的执行规则是自上往下以行为单位的，一般情况下，每一行就是一个语句。</strong>比如：var a = 1+2;  这条语句先用 var 关键词，声明了变量 a，再将 1+2 的运算结果赋值给变量 a。这里需要注意 = 符号，在 JS 中并不是等号的意思，而是赋值。再比如：alert(‘hello’);  这是一条 JS 语句，一行的结束被认定为语句的结束，通常在结尾加上一个 ; 来表示语句的结束，如果<strong>有多行 JS 语句，每句结束都有 ;，则按顺序执行语句。注意：JS 中的代码和符号都必须在英文状态下输入，虽然 ; 也可以不写，但难免会遇到一些错误，浏览器会判定前一句和后一句是可以连在一起解释的，这样就导致了一些意想不到的错误。我们要养成良好的编程习惯，记得在必须加分号的地方一定不要忘记加上。</strong></p>
</li>
<li><p>JS 对大小敏感，在编写JS代码时，需要留意是否关闭了大小写切换键.</p>
</li>
</ul>
<h2 id="JS判断语句和for循环"><a href="#JS判断语句和for循环" class="headerlink" title="JS判断语句和for循环"></a>JS判断语句和for循环</h2><ul>
<li>if 判断语句和 for 循环在 JS 中使用非常频繁。</li>
<li>通常在写代码时，总是需要为不同的决定来执行不同的动作，在代码中就可以使用 if 条件语句来完成该任务。</li>
<li>在 JS 中，可以使用以下条件语句：</li>
</ul>
<ol>
<li>if 语句：只有当指定条件为 true 时，也就是条件成立时执行的代码。</li>
<li>if… else 语句：当条件成立时执行 if 后代码，条件不成立(为 false )时执行 else 后的代码。</li>
<li>if… else if…. else 语句：使用该语句根据判断条件来选择多个代码块之一来执行。</li>
<li>实例：根据不同的时间，提示不同的问候，当时间小于12点，问候早上好，当时间大于或等于12点小于18点，问候下午好，否则都问候晚上好。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> var d = new Date();</span><br><span class="line"> var time = d.getHours();</span><br><span class="line"> if (time &lt; 12)&#123;</span><br><span class="line">     alert(&apos;早上好&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> else if (time &gt;= 12 &amp;&amp; time &lt; 18)&#123;</span><br><span class="line">     alert(&apos;下午好&apos;);</span><br><span class="line"> &#125;</span><br><span class="line">else&#123;</span><br><span class="line">     alert(&apos;晚上好&apos;);</span><br><span class="line"> &#125;</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>如果希望一遍又一遍的运行相同的代码，并且每次的值都不同，那么使用循环是很方便的，当有一组元素的时候，就可以使用 for 循环为这一组元素添加事件。<strong>for循环的语法</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (语句 1; 语句 2; 语句 3)&#123;</span><br><span class="line">  被执行的代码块</span><br><span class="line">&#125;</span><br><span class="line">语句1用于初始化循环中所有的变量。通常为：var i=0;</span><br><span class="line">语句2用于设置初始变量的条件。通常为：i&lt;object.length;</span><br><span class="line">语句3用于增加初始变量的值。通常为：i++ 也可以为：i--</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>实例</strong>：循环遍历数组中的数据，依次输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//在不使用循环时，我们可以这样输出数组中的值：</span><br><span class="line">var cars=[&quot;路虎&quot;,&quot;宝马&quot;,&quot;奔驰&quot;,&quot;奥迪&quot;,&quot;别克&quot;,&quot;大众&quot;];</span><br><span class="line">document.write(cars[0] + &quot;&lt;br&gt;&quot;); </span><br><span class="line">document.write(cars[1] + &quot;&lt;br&gt;&quot;); </span><br><span class="line">document.write(cars[2] + &quot;&lt;br&gt;&quot;); </span><br><span class="line">document.write(cars[3] + &quot;&lt;br&gt;&quot;); </span><br><span class="line">document.write(cars[4] + &quot;&lt;br&gt;&quot;); </span><br><span class="line">document.write(cars[5] + &quot;&lt;br&gt;&quot;);</span><br><span class="line">//使用for循环可以很简洁的完成输出：</span><br><span class="line">for (var i=0, i&lt;cars.length; i++)&#123;</span><br><span class="line">    document.write(cars[i] + &quot;&lt;br&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>document.write() 可用于直接向 HTML 输出流写内容，可以在平时做练习时用于向页面输出内容测试代码，这里需要注意 <strong>document.write() 一定要向文档输出写内容，如果文档已经加载完成后，再来执行该语句，则整个页面将会被覆盖。如果 document.write() 放在事件中，则会先清空页面上所有的内容，然后再写入内容。</strong></p>
</li>
</ul>
<h2 id="JS一些基本概念"><a href="#JS一些基本概念" class="headerlink" title="JS一些基本概念"></a>JS一些基本概念</h2><ol>
<li>标识符：标识符是 JS 中定义的符号，可以由任意顺序的大小写字母、数字、下划线、和美元符号( $ )组成。<strong>标识符就是识别一个具体对象的名称，最常见的标识符就是变量名和函数名，JS对大小写敏感，所以 a 和 A 是两个不同的标识符。标识符不能以数字开头，也不能是JS中的保留关键字，</strong>具体可百度参考资料。另外还有三个虽然不是保留字，但是因为他们具有特别的含义，也不能用作标识符：Infinity、NaN、undefined。</li>
<li>代码块：代码块其实不难理解，先来解释以下 JS 代码，<strong>JS 代码就是 JS 语句的序列，浏览器依据编写 JS 语句的顺序依次逐行的执行每个语句，而代码块则是 JS 语句的组合，并且包含在花括号内，代码块的作用是告诉浏览器这些代码一起执行语句序列。JS 函数就是将语句组合在块中的典型例子。</strong></li>
<li>变量：从字面上来理解，变量就是可以改变的量，但是从编程角度讲，变量是用于存储某种/某些数值信息的“容器”，简单说就是对“值”的引用，使用变量等同于引用一个值，每一个变量都有一个变量名。比如：var x = 1; 先声明一个变量 x，x 就是变量名，然后用 = 赋值，也就是将 1 赋值给 x，以后，在引用 x 的时候，就会得到值 1。在 JS 中创建一个变量通常被称为“声明”一个变量，var 就是用来声明变量的。<strong>变量在声明之后是空的，他的值为undefined（未定义），需要给他赋值后使用，= 就是建立这种引用关系。</strong>上面的代码可以看作为：var x；x=1；这样写是先声明一个变量，再给其赋值，上面的代码则在声明的同时就进行了赋值。在一条语句中，可以声明多个变量，并使用逗号隔开。注意：在给变量命名的时候不能使用 JS 关键词和 JS 保留词。</li>
<li>常量：有变量就会有常量，变量可以理解为变化的量，而常量就是不变的量。其实在 JS 中并没有常量这个概念，<strong>所谓的常量，只不过是提前赋值的变量而已。常量和变量都属于变量，只不过常量是赋过值后就不能再改变的变量，而普通的变量可以再次进行赋值操作。</strong>为了与变量有所区分，增强代码的可读性，所以在声明一个常量时，一般采用常量名全部大写，若有多个单词，可用下划线隔开。</li>
<li>字面量：<strong>所谓的字面量，其实是对象的表示形式，或者说是创建方式，他不是一种值，而是一种表示值的记法，简单说字面量就是如何表达一个对象的值，在给变量赋值时，赋值运算符后面的都可以认为是字面量。字面量也叫直接量，一个字面量，也可以被认为是一个常量，如 100。</strong>这里需要注意：<strong>变量是一个名称，而字面量是一个值。字面量可分为：数字字面量、字符串字面量和表达式字面量。数字字面量，可以是整数或者是小数，</strong>比如：var a=10; var b=3.14; 10 和 3.14 就是数字字面量。字符串字面量，使用引号包含起来的一系列字符，比如：var str=’小明’； ‘小明’就是字符串字面量。表达式字面量又可分为：数组字面量、对象字面量、函数字面量。数组字面量，每个值用逗号隔开，比如：var arr = [1,2,3,4,5,6];  [1,2,3,4,5,6] 就是数组字面量。<strong>对象字面量是一个键值对的组合，每个键值对之间用逗号分割，并包含在花括号内，</strong>比如：var obj = {a:12, b:5, c:’21’}， {a:12, b:5, c:’21’} 就是对象字面量。函数字面量，function myFunction(a, b) { return a <em> b;} 函数字面量是用关键字 function 后加可选的函数名、用圆括号括起来的参数和用花括号括起来的执行语句构成。<strong>函数字面量是一个表达式，而不是语句。</strong>上面的例子可写为：var myFunction = function (a, b)  { return a </em> b;} ，这样就有便于理解了，也可以说函数的字面量就是一个匿名函数，他的指向是归谁使用。</li>
<li>变量的作用域：<strong>变量分为：全局变量和局部变量。全局变量简单说就是在函数外声明的变量，任何地方都可以使用，而局部变量就是在函数内部声明的变量，只能在声明他的函数内部使用。这就是变量的作用域，通俗理解就是他的作用范围。JS 变量的生命期从他们被声明的时候开始，全局变量会在页面被关闭之后删除，局部变量则在函数被运行以后删除。</strong></li>
<li>表达式：<strong>表达式与数学中的定义相似，是指具有一定的值、用运算符把常量和变量连接起来的代数计算式，一个表达式可以包含常量或变量。</strong>比如：var a=a+1;  a 是变量名称，a+1 就是表达式。在生活中”再见“表达方式有很多种，比如：英语(goodbey)，网络语(886)，肢体语言(摆摆手)等。<strong>JS 中的表达式无处不在，可以表达以下几种内容：字符串的连接，被称为串表达式，</strong>var str = “I” + “love” + “you”;  还有这种形式：var str = “hello”; var str1 = str + “World”;  串表达式值为字符串。数值表达式，var num = 10 + 2.5;  也有如下形式：var num = 10 + 2.5; var num1 = num + 10 * 2.5;  数值表达式值为数值。还是有一种是布尔表达式，var num = 2; alert(num == 2); 返回 ture，alert(num &gt; 10); 返回 false。<strong>布尔表达式值为 true 或 false。</strong></li>
<li><p>函数：一看到函数，很多人可能就头疼，但是编程中函数还是很好理解的，是由事件驱动的或者当它被调用时执行的可重复使用的代码块。简单说就是完成某个特定功能的一组语句，<strong>使用function关键字定义包裹在花括号中的代码块，便于反复调用。其基本形式为：function moveStart(){代码} 。声明一个函数只是在告诉浏览器这有一个函数，不会被实际执行，而在函数调用的时候，才真正执行函数内的代码。</strong>moveStart 就是函数名，遵循 JS 命名规范，在函数调用的时候使用：moveStart()。<strong>若将函数定义在变量后，变量则可作为函数使用。函数存储在变量中，不需要函数名，可以通过变量名调用。我们把没有名称的函数称为匿名函数。函数返回值，函数执行的结果就是函数返回值，return 可以将函数内的结果返回到函数外调用，在使用 return 语句时，函数会停止执行，并返回指定的值，再从调用的地方开始执行，函数调用会被返回值取代，同样一个函数应该只返回一种类型的值，在仅仅是希望退出函数时，也可以使用 return，返回值是可选的，</strong>比如下面的代码：如果 a 大于 b，则退出函数，并不会计算 a 和 b 的和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function myFunction(a, b)&#123;</span><br><span class="line">    if (a &gt; b)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    x = a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数传参：<strong>在调用函数时，可以向其传递值，这些值被称为参数，这些参数可以在函数中使用，可以传递任意多的参数，并由逗号分割，</strong>比如：function myFunction(x, y){return x * y;} ，在调用的时候传入值：myFunction(3 ,4)，则返回 x乘y 的运算结果。简单理解，<strong>参数就是一个占位符，即先把位置占住，后面再用。传递的值必须与参数以一致的顺序出现，第一个值就是第一个被传递的参数给定的值，依次类推。函数很灵活，可以传递不同的值，来调用该函数。函数参数可分为：显式参数和隐藏参数( arguments )。函数的显式传参，也叫固定参，就是在函数被声明定义的时候列出的参数。隐藏参数也叫可变参，或者不定参，arguments 对象是 JS 内置的对象，对象包含了函数调用的参数数组，通过这一点可以很方便的找到最后一个参数的值，或者计算所有参数的和。</strong>当函数里有一部分定不下来的时候可以用函数传参，举一个简单的例子：点击按钮改变 DIV 的样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">#div1&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    background:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;变宽&quot; onclick=&quot;setWid(&apos;width&apos;,&apos;400px&apos;)&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;变高&quot; onclick=&quot;setWid(&apos;height&apos;,&apos;400px&apos;)&quot; /&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;变绿&quot; onclick=&quot;setWid(&apos;background&apos;,&apos;green&apos;)&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function setWid(name, value)&#123;    //函数传参</span><br><span class="line">    var x = document.getElementById(&apos;div1&apos;);</span><br><span class="line">    x.style[name] = value;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//参数求和：</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function sumArr() &#123;</span><br><span class="line">    var result = 0;</span><br><span class="line">    for(var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        result += arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125; </span><br><span class="line">alert(sumArr(3,5,2,12,8,51,99));    //和为：180</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<ol start="10">
<li><strong>对象：</strong>在现实生活中，一个人可以被视为一个对象，对象有他的属性，比如性别、身高、年龄，籍贯等，方法有：走、跑、跳等。所有的人都有这些属性，但是每个人的属性又不尽相同，所有的人都有这些方法，但是他们执行的时间都不尽相同。在 JS 中，<strong>对象就是拥有属性和方法的数据，JS 中的所有事物都是对象：字符串、日期、数组、数字等等。可以说在 JS 中一切皆对象，属性是与对象相关的值，方法是能够在对象上执行的动作。简单说对象只是带有属性和方法的特殊数据类型。在 JS 中对象是数据（变量），拥有属性和方法，当在声明一个变量时，</strong>var txt = “你好”； 实际上已经创建了一个字符串对象，该对象拥有 length 属性，字符串对象同时拥有很多个内置的方法，比如：charAt() 可获取某个字符，返回字符串的某一位的字符。<strong>可以说 JS 对象是变量的容器，但是，通常认为 JS对象是键值对的容器，键值对的写法为：name:value，键与值以冒号分隔，键值对又常被称为对象属性，所以 JS 对象就是属性变量的容器。JS支持自定义对象，可以通过 new 关键字创建。</strong></li>
</ol>
<h2 id="JS数据类型"><a href="#JS数据类型" class="headerlink" title="JS数据类型"></a>JS数据类型</h2><ul>
<li><strong>JS 数据类型可分为基本数据类型和复合数据类型两种，其中基本数据类型有五种：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）。复合数据类型即 Object，Object 本质是一组无序的名值对组成的，严格来说，又被分为三类：对象(Object)、数组(Array)、函数（function）。</strong></li>
</ul>
<ol>
<li>字符串：字符串是存储字符的变量。比如：var a=’小明’;，字符串可以是引号中的任意文本，可以使用单引号或者双引号。</li>
<li>数字：数字就是用来存储数字的变量。可以为整数也可以是小数。比如：var a1=314; var a2=3.14；。</li>
<li>布尔：布尔值是 “ture” 真和 “false” 假两个特定值，布尔常用在条件测试中。</li>
</ol>
<ul>
<li><strong>什么是真 ture：非零数字、非空字符串、非空对象</strong></li>
<li><strong>什么是假 false：数字零、空字符串、空对象(null)、undefined</strong></li>
</ul>
<ol start="4">
<li>Null：<strong>null 是一个只有一个值的特殊类型，表示一个空对象引用，可以用来清空变量。</strong></li>
<li>Undefined：表示为定义，有两种情况：1：真的没有定义。2、虽然定义了，但是没有赋值。</li>
<li>Object：<strong>对象由大括号包含。在括号内部，对象的属性以名称和值对的形式{name : value}来定义。属性由逗号分隔，包括了除数字、字符串和布尔值以外的所有类型。</strong>比如：var person = {name:”小明”, sex:”男”, id:5566};，此例子中的对象（person）有三个属性：name， sex，id。</li>
<li>Array：使用单独的变量名来存储一系列的值。创建一个数组的方法：var arr = new Array();，之后可以给数组添加值：arr[0] = 1; arr[1] = 2; arr[2] = 3;，<strong>数组的下标是基于零的，所以从 0 开始算起。在 JS 中，很多时候，要避免使用 new 关键字，所以将数组创建为：var arr = [1,2,3] 的形式。</strong></li>
<li>function：<strong>函数其实是处理数据的方法，JS 将函数视为一种数据类型，可以像其他数据类型一样，进行赋值和传递，</strong>这就为编程带来了很大的灵活性。</li>
</ol>
<ul>
<li>变量的类型：<strong>变量本身是没有类型的，取决于他里边存储的什么数据类型，存的什么类型就是什么类型的变量。</strong>当声明新变量时，可以使用 new 来声明其类型，比如：var userName = new String;  var x = new Number;  var y = new Boolean;  var cars = new Array;  var person = new Object; 。<strong>JS 变量均为对象，当声明一个变量时，就创建了一个新的对象。</strong></li>
<li>typeof运算符：<strong>typeof 操作符用来检测变量的数据类型，返回一个字符串。字符串、数字、布尔值分别返回 string、number、boolean。用 typeof 检测 null 返回 object，在 JS 中 null 表示什么都没有，但是他是一个对象。undefined 是没有赋值的变量，所以 typeof 一个没有值的变量会返回 undefined。typeof 一个对象则返回 object。JS 中数组是一种特殊类型的对象，所以也返回 object。函数则返回 function。</strong></li>
<li><strong>undefined 和 null 的区别：typeof undefined，返回 undefined。typeof null，返回 object。(null === undefined)，返回 false，(null == undefined)，返回true。</strong></li>
</ul>
<h2 id="JS运算符"><a href="#JS运算符" class="headerlink" title="JS运算符"></a>JS运算符</h2><h2 id="算数运算符："><a href="#算数运算符：" class="headerlink" title="算数运算符："></a>算数运算符：</h2><ul>
<li>除了平时常见的加减乘数之外，JS 中还有一些其他的运算符：</li>
</ul>
<ol>
<li><strong>取模运算符：</strong>%，取模通俗理解就是取余数，比如：5%2，值为1，5除2，商2余1。</li>
<li><strong>自增运算符：++，</strong>自增运算分为两种情况，一种是先赋值再运算，一种是先运算再赋值。实例：假设 a = 2</li>
<li><strong>先赋值再运算：</strong>var b = a++; 运算结果为：b=2，a=3 解析：b = a，a = a+1。</li>
<li><strong>先运算再赋值：</strong>var b = ++a；运算结果为：b=3，a=3 解析：a = a+1，b = a。</li>
</ol>
<ul>
<li>通过上面的例子，可以看到，先赋值再运算，实质是先把 a 赋值给 b，然后自己再加 1。先运算再赋值，实质是先自己加 1，再把值赋给 b。</li>
<li>他们的相同点都是自增1，a = a+1，都被作为一个整体表达式运算，即 (a++)(++a)，虽然他们的值都自增 1，但是 (a++) 取 a 自增前的值，而 (++a) 取 a 自增后的值。</li>
</ul>
<ol start="5">
<li><strong>自减运算符：–，</strong>自减运算符和自增运算符一样，即每次自减1。也分为两种情况：实例：假设a=2</li>
<li><strong>先赋值再运算：</strong>var b=a–; 运算结果为：b=2，a=1 解析：b=a，a=a-1。</li>
<li><strong>先运算再赋值：</strong>var b=–a；运算结果为：a=1，b=1 解析：a=a-1，b=a。</li>
</ol>
<ul>
<li>运算符可用于字符串变量的连接，若需要把多个字符串连接起来，就可以使用 + 运算符。</li>
<li>如果把字符串和数字相加，则得到一个字符串。比如：var str=’hello’+2; 返回：hello2</li>
</ul>
<h3 id="赋值运算符："><a href="#赋值运算符：" class="headerlink" title="赋值运算符："></a>赋值运算符：</h3><ul>
<li><strong>赋值运算符用于给变量赋值。有以下几种：</strong>= += -= *= /= %=<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">实例：假设 a=10 b=5</span><br><span class="line">=：a = b 结果：5</span><br><span class="line">+=：a += b，相当于：a = a+b 结果：15</span><br><span class="line">-=：a -= b，相当于：a = a-b 结果：5</span><br><span class="line">*=：a *= b，相当于：a = a*b 结果：50</span><br><span class="line">/=：a /= b，相当于：a = a/b 结果：2</span><br><span class="line">%=：a % b，相当于：a = a/b 结果：0 (取模运算是取余数)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="比较运算符："><a href="#比较运算符：" class="headerlink" title="比较运算符："></a>比较运算符：</h3><ul>
<li>比较运算符在条件语句中使用，用于判断变量或值的关系，返回 ture 或 false。</li>
<li>比较运算符有以下几种：== === != !== &gt; &lt; &gt;= &lt;=<br>实例：假设 a=2</li>
</ul>
<ol>
<li>==：等于。注意双等号在JS中才表示等于，一个等号为赋值。比较：a == 2，返回 ture。a == 1，返回false。</li>
<li>===：绝对等于，值和类型均相等。比较：a === ‘2’，返回 false。a === 2，返回 true。</li>
<li>!=：不等于。和等于相反。比较：a != 2，返回 false，a != 1，返回 ture。</li>
<li>!==：绝对不等于，和绝对等于相反，值和类型均不相等。比较：a !== ‘2’，返回 ture，a !== 2，返回 false。</li>
<li><blockquote>
<p>：大于。比较：a&gt;5，返回false。</p>
</blockquote>
</li>
<li>&lt;：小于。比较：a&lt;5，返回ture。</li>
<li><blockquote>
<p>=：大于等于。比较：a&gt;=5，返回false。</p>
</blockquote>
</li>
<li>&lt;=：小于等于。比较：a&lt;=5，返回ture。</li>
</ol>
<p>###逻辑运算符：</p>
<ul>
<li>逻辑运算符用于描述变量或值之间的逻辑关系。</li>
<li>逻辑运算符有以下几种：&amp;&amp; || !</li>
</ul>
<ol>
<li>&amp;&amp;：并且。在数学中我们将 b 大于 a、b 又小于 c 表示为：a&lt;b&lt;c，但是在 JS 中要用 &amp;&amp; 表示：b&gt;a &amp;&amp; b&lt;c。两个条件必须同时满足，则返回 ture，有一个条件不满足，则返回 false。实例：判断一个数字是否为两位数：a&gt;9 &amp;&amp; a&lt;100，假设 a=50，则返回：ture。</li>
<li>||：或。当两个条件中，有任一个条件满足，逻辑或的运算结果就为真。实例：a=5，b=10，判断c=a&lt;b || a == b ，c的值为：ture。</li>
<li>!：否。也叫逻辑非操作符，是非颠倒，好比小明买了一本 JS 书籍，小白说：是乌龟书；小红说：是犀牛书。小明说：小白说的不是真话，小红说的不是假话。那么是小红说对了，小明买的书是犀牛书。实例：a=10 b=5，判断c =! (a&gt;b)，c 的值为：false。 </li>
</ol>
<h3 id="三元运算符："><a href="#三元运算符：" class="headerlink" title="三元运算符："></a>三元运算符：</h3><ul>
<li>三元运算符也叫条件运算符，其基本形式可用 if 判断语句表示，用三元运算符表示为： ？ ：。</li>
<li>所谓三元运算符，顾名思义就是需要进行三次操作，语法为：条件?结果1:结果2 。条件写在问号之前，后面跟着用冒号分隔的结果1和结果2，当满足条件时为结果1，否则就是结果2。好比你去看演唱会，条件就是需要入场券，若你带了就可以直接进去，如果没带那就请回吧，用三元运算符可表示为：带没带入场券 ? 带了直接进去 : 没带那就请回吧。</li>
<li>所有使用 if 判断语句的地方，都可以使用三元运算符，使用 if 判断语句代码比较繁琐，使用三元运算符，代码则十分简洁，但是对于初学者来说，三元运算符不是那么直观，使用 if 判断语句更容易理解，随着学习的不断深入，以及理解的加深，就可以使用三元运算符代替 if 了。</li>
<li>实例：判断一个数为偶数还是奇数。假设：a=12</li>
<li><p>先用 if 判断语句表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = 12;</span><br><span class="line">if(a%2 == 0)&#123;</span><br><span class="line">    alert(&apos;a为偶数&apos;);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    alert(&apos;a为奇数&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用三元运算符可表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 12;</span><br><span class="line">a%2===0 ? alert(&apos;偶数&apos;) : alert(&apos;奇数&apos;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="运算符之间的优先级："><a href="#运算符之间的优先级：" class="headerlink" title="运算符之间的优先级："></a>运算符之间的优先级：</h3><ul>
<li>从高到低依次为：算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号</li>
<li>同级的运算是按从左到右依次进行运算，若有括号，从多层括号由里向外进行运算。</li>
<li>实例： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numA = 2;</span><br><span class="line">var numB = 5;</span><br><span class="line">var numC = numA + 40 &gt; 10 $$ numB * 2 &lt; 20;</span><br><span class="line">var numD =( ( numA + 40 )  /  ( 12 - numB ) ) * 10;</span><br><span class="line">alert(numC);    //返回：ture</span><br><span class="line">alert(numD);    //返回：60</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="JS事件"><a href="#JS事件" class="headerlink" title="JS事件"></a>JS事件</h2><ul>
<li><strong>HTML 事件是发生在 HTML 元素上的事情。当在 HTML 页面中使用 JS 时，JS 可以触发这些事件。事件可以是浏览器行为，也可以是用户操作行为，用户操作行为可分为鼠标操作和键盘操作。</strong>比如：在页面加载完成时触发事件，这属于浏览器行为，用户的操作行为如点击按钮触发事件，鼠标的移入移出，按键提交信息等。</li>
<li>下面是一些常用的事件列表：</li>
</ul>
<table>
<thead>
<tr>
<th>事件</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>onload</td>
<td style="text-align:right">页面已完成加载时触发事件</td>
</tr>
<tr>
<td>onresize</td>
<td style="text-align:right">调整浏览器大小时触发事件</td>
</tr>
<tr>
<td>onchange</td>
<td style="text-align:right">当元素改变时触发事件</td>
</tr>
<tr>
<td>onfocus</td>
<td style="text-align:right">当元素获得焦点时触发事件</td>
</tr>
<tr>
<td>onselect</td>
<td style="text-align:right">当选取元素时触发事件</td>
</tr>
<tr>
<td>onsubmit</td>
<td style="text-align:right">用户提交表单时触发事件</td>
</tr>
<tr>
<td>onclick</td>
<td style="text-align:right">点击鼠标时触发事件</td>
</tr>
<tr>
<td>onmouseover</td>
<td style="text-align:right">鼠标移入时触发事件</td>
</tr>
<tr>
<td>onmouseout</td>
<td style="text-align:right">鼠标移出时触发事件</td>
</tr>
<tr>
<td>onmousedown</td>
<td style="text-align:right">按下鼠标时触发事件</td>
</tr>
<tr>
<td>onmouseup</td>
<td style="text-align:right">松开鼠标时触发事件</td>
</tr>
<tr>
<td>onmousemove</td>
<td style="text-align:right">移动鼠标时触发事件</td>
</tr>
<tr>
<td>onmousewheel</td>
<td style="text-align:right">用户滚动鼠标滚轮时触发事件</td>
</tr>
<tr>
<td>onscroll</td>
<td style="text-align:right">当滑动滚动条时触发事件</td>
</tr>
<tr>
<td>onkeydown</td>
<td style="text-align:right">用户按下键盘按键时触发事件</td>
</tr>
<tr>
<td>onkeyup</td>
<td style="text-align:right">用户松开按键时触发事件</td>
</tr>
</tbody>
</table>
<h2 id="JS常用的互动方法"><a href="#JS常用的互动方法" class="headerlink" title="JS常用的互动方法"></a>JS常用的互动方法</h2><ul>
<li><strong>在 JS 中可以创建三种类型的消息框：警告框、确认框、提示框。</strong></li>
</ul>
<ol>
<li><strong>警告框</strong></li>
</ol>
<ul>
<li>警告框常用于确保用户可以得到某些信息，平时我们在访问网页的时候，有时突然弹出一个小窗口，上面写这一些提示文字，这就是警告框，在警告框出现之后，用户必须点击确定按钮后才能继续操作，否则就不能对网页做出任何操作。这样的弹出窗口是用”alert“实现的。</li>
<li><strong>语法：alert(str或var);</strong></li>
</ul>
<ol start="2">
<li><strong>确认框</strong></li>
</ol>
<ul>
<li>确认框常用于验证用户是否接受操作，允许用户做出选择，当确认框弹出时，用户可以点击”确定“或者”取消“来确定用户操作，当用户点击确定时，返回值为 ture，如果点击取消，则返回值为 false。用户在点击对话框之前不能进行任何操作。这样的弹出窗口是用”confirm“实现的。</li>
<li><strong>语法：confirm(str);</strong></li>
</ul>
<ol start="3">
<li><strong>提示框</strong></li>
</ol>
<ul>
<li>提示框也叫提问框，用于提示用户在进入页面前输入某个值，主要是询问一些需要与用户交互的信息，提示框包含一个确定、取消按钮，和一个文本框，当提示框弹出后，用户需要输入某个值，然后点击确定或者取消才能继续操作，当用户点击确认时，返回值为文本框输入的值，如果用户点击取消，则返回值为null。提示框可以和确认框相互配合使用。这样的弹出窗口是用”prompt“实现的。</li>
<li><strong>语法：prompt(str1, str2);</strong></li>
<li>str1 为要显示在对话框的值，也就是与用户交互的内容描述，不可修改。str2 为文本框中提示用户输入的默认内容，可以修改。</li>
</ul>
<ul>
<li>一般情况下，在实际的网站中，这些对话框都很少或者说几乎不使用，尤其是警告框，因为用户会反感这种突然弹出来的东西，在弹出对话框后用户不点击按钮之前，浏览器就跟死了一样，不能做任何操作，确认框和提示框相对来说还有一些使用，也是比较有意义的，比如页面中一个跳转按钮，如果不使用确认对话框，则直接跳转到新页面，使用确认对话框之后，用户可以点击确认或者取消来执行对应操作，确认则跳转新页面，取消则继续浏览，有时候这个跳转按钮或者链接是用户不小心点到的，并不希望跳转。大部分网站中，都使用的是一套自定义的对话框，更友好的显示。</li>
</ul>
<h2 id="JS转义字符"><a href="#JS转义字符" class="headerlink" title="JS转义字符"></a>JS转义字符</h2><ul>
<li>在 JS 中字符串通常用单引号或双引号包含起来，比如：var txt = “谁看到”小明”今天来上课了吗？”; 所以这个例子会解析错误，从 “谁看到” 被截断，浏览器报错提示：语法错误，而且这是很严重的错误，错误到代码将被终止，后面的代码无法执行。其实这个例子还是很好解决的，我们可以将其用单引号括起来，再给小明加上双引号，OK，跟原来要表达的一样，但是如果我们需要换行呢？这时候就需要用到转义字符，转义字符在 JS 中应用十分广泛，尤其是在正则表达式 (RegExp) 中，因此上面的代码应该写为： var txt = “谁看到 \”小明 \”今天来上课了吗？”;  需要换行则写为：var txt = “谁看到 \”小明 \” \n 今天来上课了吗？”; 。</li>
<li>**反斜杠()是一个转义字符，转义字符可用于将特殊字符转换为字符串字符，可以用于转义撇号、引号、换行等其他特殊字符，在编写代码时需要注意特殊字符问题，很多运行时出现的问题都是因为特殊字符而引起的，由于反斜杠本身被用作转义符，因此不能在代码中只键入一个 \ ，如果需要显示一个反斜杠，必须一次键入两个 \ </li>
</ul>
<hr>
<h5 id="👏👏👏小编有话讲"><a href="#👏👏👏小编有话讲" class="headerlink" title="👏👏👏小编有话讲:"></a>👏👏👏小编有话讲:</h5><pre><code>以上小编的总结如有异议,欢迎指导!!!😃💖
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/05/JavaScript-summarize/" data-id="cjkg9cxex0004jsv79rhulozt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Cmd-Markdown" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/01/Cmd-Markdown/" class="article-date">
  <time datetime="2018-07-01T12:33:59.000Z" itemprop="datePublished">2018-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/01/Cmd-Markdown/">Cmd-Markdown</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="欢迎使用-Cmd-Markdown-编辑阅读器"><a href="#欢迎使用-Cmd-Markdown-编辑阅读器" class="headerlink" title="欢迎使用 Cmd Markdown 编辑阅读器"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr>
<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p>
<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>
<h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote>
<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>
</blockquote>
<hr>
<h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>
<h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul>
<li style="list-style: none"><input type="checkbox"> 支持以 PDF 格式导出文稿</li>
<li style="list-style: none"><input type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li style="list-style: none"><input type="checkbox" checked> 新增 Todo 列表功能</li>
<li style="list-style: none"><input type="checkbox" checked> 修复 LaTex 公式渲染问题</li>
<li style="list-style: none"><input type="checkbox" checked> 新增 LaTex 公式编号功能</li>
</ul>
<h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p>
<h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure>
<h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>
<h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure>
<h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></table></figure>
<h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">\$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">\$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">\$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="noopener">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>
<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>
<hr>
<h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>
<h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>
<h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p>
<h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>
<h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>
<h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>
<h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p>
<p>通过管理工具栏可以：</p>
<p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>
<h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p>
<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>
<p>工具栏上的五个图标依次为：</p>
<p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>
<h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>
<h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>
<p>标签： 未分类</p>
<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>
<p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p>
<h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>
<hr>
<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>
<p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="noopener">@ghosert</a><br>2016 年 07月 07日    </p>
<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p>
<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/01/Cmd-Markdown/" data-id="cjkg9cxel0001jsv7lzm9yftt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/01/hello-world/" class="article-date">
  <time datetime="2018-07-01T11:44:07.710Z" itemprop="datePublished">2018-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/01/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/01/hello-world/" data-id="cjkg9cxeg0000jsv7ec1mc71d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/05/Flex/">Flex</a>
          </li>
        
          <li>
            <a href="/2018/07/27/GitHub/">GitHub</a>
          </li>
        
          <li>
            <a href="/2018/07/11/node-js/">node.js</a>
          </li>
        
          <li>
            <a href="/2018/07/05/JavaScript-summarize/">JavaScript-summarize</a>
          </li>
        
          <li>
            <a href="/2018/07/01/Cmd-Markdown/">Cmd-Markdown</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>